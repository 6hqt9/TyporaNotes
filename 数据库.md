# 基本知识

## 基本概念

| **DB：数据库（Database）**                                   |
| ------------------------------------------------------------ |
| 即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据 |
| **DBMS：数据库管理系统（Database Management System）**==>MySQL |
| 是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据 |
| **SQL：结构化查询语言（Structured Query Language）**         |
| 专门用来与数据库通信的语言                                   |

## 常见数据库

- **Oracle**

  1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气 越来越大，公司也改名叫 Oracle 公司

  2007年，总计85亿美金收购BEA Systems

  2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle同时拥有了MySQL的管理权，至此 Oracle 在数据库领域中成为绝对的领导者

  2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司

  如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值

- **SQL Server**

  SQL Server 是微软开发的大型商业数据库，诞生于1989年。C#、.net等语言常使用，与WinNT完全集成，也可以很好地与Microsoft BackOffice产品集成。 

- **DB2**

  IBM公司的数据库产品,收费的。常应用在银行系统中

- **PostgreSQL**

  PostgreSQL 的稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以及SQL处理较快

- **SyBase**

  已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。 

- **SQLite**

  嵌入式的小型数据库，应用在手机端。 零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复

- **informix**

  IBM公司出品，取自Information 和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行于unix/linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用

### Oracle vs MySQL

`Oracle`更适合**大型跨国企业**的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求

`MySQL`由于其**体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码**这一特点，使得很多**互联网公司、中小型网站**选择了MySQL作为网站数据库（Facebook，Twitter， YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）

## RDBMS与非RDBMS

关系型数据库是DBMS的主流，其中使用最多的DBMS分别是Oracle、MySQL和SQL Server。这些都是关系型数据库（RDBMS）

### RDMBS

`RDMBS`(Relational Database Management System)：**关系型数据库**

RDBMS使用SQL操作

#### 实质

- 这种类型的数据库是`最古老`的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的`二元关系`（即二维表格形式）
- 关系型数据库以`行(row)`和`列(column)`的形式存储数据，以便于用户理解。这一系列的行和列被称为`表(table)`，一组表组成了一个`库(database)`
- 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用`关系模型`来表示。**关系型数据库，就是建立在`关系模型`基础上的数据库**
- SQL就是关系型数据库的查询语言

#### 优势

- **复杂查询**：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询
- **事务支持**：使得对于安全性能很高的数据访问要求得以实现

### 非RDBMS

`非RDMBS`(Relational Database Management System)：**非关系型数据库**

非RDMBS使用NoSQL操作

#### 实质

**非关系型数据库**：可看成`传统关系型数据库`的功能`阉割版本`，基于键值对存储数据，不需要经过SQL层的解析，`性能非常高`。同时，通过减少不常用的功能，进一步提高性能

目前基本上大部分主流的非关系型数据库都是免费的

#### 分类

相比于 SQL，NoSQL 泛指非关系型数据库，包括了键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用`NoSQL`一词才能将这些技术囊括进来

##### **键值型数据库**

键值型数据库通过`Key-Value`键值的方式来存储数据，其中Key和Value可以是简单的对象，也可以是复杂的对象。Key作为唯一的标识符，优点是`查找速度快`，在这方面明显优于关系型数据库，缺点是`无法像关系型数据库一样使用条件过滤`（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算

键值型数据库典型的使用场景是作为`内存缓存`。`Redis`是最流行的键值型数据库

##### **文档型数据库**

此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。`MongoDB`是最流行的文档型数据库。此外，还有`CouchDB`等

##### **搜索引擎数据库**

虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”

典型产品：`Elasticsearch`、`Solr`、`Splunk`等

##### **列式数据库**

列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限

典型产品：`HBase`等

##### **图形数据库**

图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题

图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象） 之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社 交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：`Neo4J`、`InfoGrid`等

# MySQL

- MySQL是一个`开放源代码的关系型数据库管理系统`，由瑞典MySQL AB（创始人Michael Widenius）公 司1995年开发，迅速成为开源数据库的 No.1
- 2008被`Sun`收购（10亿美金），2009年Sun被`Oracle`收购。`MariaDB`应运而生。（MySQL 的创 造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB）
- MySQL6.x 版本之后分为`社区版`和`商业版`
- MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库 内，这样就增加了速度并提高了灵活性
- MySQL是开源的，所以你不需要支付额外的费用
- MySQL是可以定制的，采用了`GPL（GNU General Public License）`协议，你可以修改源码来开发自己的MySQL系统
- MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库
- MySQL支持大型数据库，支持5000万条记录的数据仓库，`32位系统`表文件最大可支持`4GB`，`64位系统`支持最大的表文件为`8TB`
- MySQL使用`标准的SQL数据语言`形式
- MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP和Ruby等

**优点**：

1. 开放源代码，使用成本低
2. 性能卓越，服务稳定
3. 软件体积小，使用简单，并且易于维护
4. 历史悠久，社区用户非常活跃，遇到问题可以寻求帮助
5.  许多互联网公司在用，经过了时间的验证。

## 常用指令

| **启动服务**                                                 |
| ------------------------------------------------------------ |
| net start MySQL80                                            |
| **停止服务**                                                 |
| net stop MySQL80                                             |
| **登录**                                                     |
| mysql -h 主机名 -P 端口号 -u 用户名 -p密码                   |
| `-p与密码之间不能有空格`，其他参数名与参数值之间可以有空格也可以没有空格 |
| eg1：mysql -hlocalhost -P3306 -uroot -pabc123                |
| eg2：mysql -h localhost -P 3306 -u root -p                   |
| eg3：mysql -u root -p                                        |
| **查看版本**                                                 |
| mysql -V                                                     |
| mysql --version                                              |
| select version()（登录后指令）                               |
| **退出**                                                     |
| exit                                                         |
| quit                                                         |
| **查看编码**                                                 |
| show variables like 'character_%';                           |
| show variables like 'collation_%';                           |
| **导入数据**                                                 |
| source 路径.sql                                              |

## 基本事项说明

### 初始四库

**information_schema**：主要保存 MySQL 数据库服务器的系统信息， 比如数据库的名称、数据表的名称、字段名称、存取权限、数据文件 所在的文件夹和系统使用的 文件夹，等等

**performance_schema**：可以用来监控 MySQL 的各类性能指标。

**sys**：主要作用是以一种更容易被理解的方式展示 MySQL 数据 库服务器的各类性能指标，帮助系统管理员和开发人员监控 MySQL 的技术性能。

**mysql**：保存了MySQL数据库服务器运行时需要的系统信息，比如数据文件夹、当前使用的 字符集、约束检查信息，等等

### 目录结构

| 目录结构                | 说明                                 |
| ----------------------- | ------------------------------------ |
| bin目录 (Program Files) | 所有MySQL的可执行文件，如：mysql.exe |
| data目录(ProgramData)   | 系统数据库及创建所在目录             |
| my.ini                  | MySQL的主要配置文件                  |

## SQL概述

### SQL分类

SQL语言在功能上主要分为如下3大类：

- **DDL（Data Definition Languages、数据定义语言）**，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。 
  - 主要的语句关键字包括`CREATE`、`DROP`、`ALTER`等
- **DML（Data Manipulation Language、数据操作语言）**，用于添加、删除、更新和查询数据库记录，并检查数据完整性
  - 主要的语句关键字包括`INSERT`、`DELETE`、`UPDATE`、`SELECT`等
  - **SELECT是SQL语言的基础，最为重要**
- **DCL（Data Control Language、数据控制语言）**，用于定义数据库、表、字段、用户的访问权限和安全级别
  - 主要的语句关键字包括`GRANT`、`REVOKE`、`COMMIT`、`ROLLBACK`、`SAVEPOINT`等。

> 因为`查询语句`使用的非常的频繁，所以很多人把查询语句单拎出来一类：**DQL（数据查询语言）**
>
> 还有单独将`COMMIT`、`ROLLBACK`取出来称为**TCL（Transaction Control Language，事务控制语言）**

### SQL规则规范

#### 基本规则

- SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进
- 每条命令以 ; 或 \g 或 \G 结束
- 关键字不能被缩写也不能分行
- 关于标点符号
  - 必须保证所有的()、单引号、双引号是成对结束的
  - 必须使用英文状态下的半角输入方式
  - `字符串`型和`日期时间`类型的数据可以使用`单引号（' '）`表示
  - 列的[别名](#as)，尽量使用`双引号`（`" "`），而且`不建议省略as`

#### 大小写规范

- **MySQL 在 Windows 环境下是大小写不敏感的**
- **MySQL 在 Linux 环境下是大小写敏感的**
  - 数据库名、表名、表的别名、变量名是严格区分大小写的
  - 关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。 
- **推荐采用统一的书写规范：**
  - `数据库名`、`表名`、`表别名`、`字段名`、`字段别名`等都`小写`
  - `SQL 关键字`、`函数名`、`绑定变量`等都`大写`

#### 注释

可以使用如下格式的注释结构：

```sql
单行注释：#注释文字(MySQL特有的方式)
单行注释：-- 注释文字(--后面必须包含一个空格。)
多行注释：/* 注释文字（多行注释不能嵌套） */
```

#### 命名规则

- 数据库、表名不得超过30个字符，变量名限制为29个
- 必须只能包含 A–Z, a–z, 0–9, _共63个字符
- 数据库名、表名、字段名等对象名中间不要包含空格
- 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名
- 必须保证你的`字段没有和保留字、数据库系统或常用方法冲突`。如果坚持使用，请在SQL语句中使用 `（着重号）引起来
- 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了

### 常用SQL标准

SQL 有两个主要的标准，分别是`SQL92`和`SQL99`。92 和 99 代表了标准提出的时间，SQL92 就是 92 年 提出的标准规范。当然除了 SQL92 和 SQL99 以外，还存在 SQL-86、SQL-89、SQL:2003、SQL:2008、 SQL:2011 和 SQL:2016 等其他的标准。

这么多标准，到底该学习哪个呢？**实际上最重要的 SQL 标准就是 SQL92 和 SQL99**。一般来说SQL92的形式更简单，但是写的SQL语句会比较长，可读性较差。而 SQL99 相比于SQL92来说，语法更加复杂，但可读性更强。我们从这两个标准发布的页数也能看出。SQL92的标准有500页，而 SQL99 标准超过了1000页。实际上从 SQL99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用 Windows、Linux 和 Office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满足日常工作的需求即可。

**SQL92 和 SQL99 是经典的 SQL 标准，也分别叫做 SQL-2 和 SQL-3 标准**。也正是在这两个标准发布之 后，SQL影响力越来越大，甚至超越了数据库领域。现如今SQL已经不仅仅是数据库领域的主流语言，还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 SQL 语言的使用



## 数据类型

### 总览与属性

| 类型                                  | 举例                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| [整数类型](#整数类型)                 | TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT         |
| [浮点类型](#浮点类型)                 | FLOAT、DOUBLE                                                |
| [定点数类型](#定点数类型)             | DECIMAL                                                      |
| [位类型](#位类型)                     | BIT                                                          |
| [日期时间类型](#日期时间类型)         | YEAR、TIME、DATE、DATETIME、TIMESTAMP                        |
| [文本字符串类型](#文本字符串类型)     | CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT          |
| [枚举类型](#枚举类型)                 | ENUM                                                         |
| [集合类型](#集合类型)                 | SET                                                          |
| [二进制字符串类型](#二进制字符串类型) | BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB      |
| [JSON类型](#JSON类型)                 | JSON对象、JSON数组                                           |
| [空间数据类型](#空间数据类型)         | 单值类型：GEOMETRY、POINT、LINESTRING、POLYGON；<br />集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION |

常见数据类型的**属性**如下：

详见[约束](#约束)

| MySQL关键字        | 含义                     |
| ------------------ | ------------------------ |
| NULL               | 数据列可包含NULL值       |
| NOT NULL           | 数据列不允许包含NULL值   |
| DEFAULT            | 默认值                   |
| PRIMARY KEY        | 主键                     |
| AUTO_INCREMENT     | 自动递增，适用于整数类型 |
| UNSIGNED           | 无符号                   |
| CHARACTER SET name | 指定一个字符集           |

### <a id="整数类型">整数类型</a>

#### 类型介绍

整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。

它们的区别如下表所示：

| **整数类型** | **字节** | 有符号数取值范围                         | 无符号数取值范围       |
| ------------ | -------- | ---------------------------------------- | ---------------------- |
| TINYINT      | 1        | -128~127                                 | 0~255                  |
| SMALLINT     | 2        | -32768~32767                             | 0~65535                |
| MEDIUMINT    | 3        | -8388608~8388607                         | 0~16777215             |
| INT、INTEGER | 4        | -2147483648~2147483647                   | 0~4294967295           |
| BIGINT       | 8        | -9223372036854775808~9223372036854775807 | 0~18446744073709551615 |

#### 可选属性

**整数类型的可选属性有三个**：

##### M

**M**: 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。该项功能需要配合` ZEROFILL `使用，表示用`0`填满宽度，否则指定显示宽度无效

如果设置了显示宽度，那么**插入的数据宽度超过显示宽度限制，不会截断或插入失败，不会对插入的数据有任何影响**，还是按照类型的实际宽度进行保存，即`显示宽度与类型可以存储的值范围无关`。**从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性**。

整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认 的宽度值。

举例：

```mysql
CREATE TABLE test_int1 ( x TINYINT, y SMALLINT, z MEDIUMINT, m INT, n BIGINT );
```

查看表结构 （MySQL5.7中显式如下，MySQL8中不再显式范围）

```mysql
mysql> desc test_int1;
+-------+--------------+------+-----+---------+-------+
| Field |     Type     | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
|   x   | tinyint(4)   | YES  |     | NULL    |       |
|   y   | smallint(6)  | YES  |     | NULL    |       |
|   z   | mediumint(9) | YES  |     | NULL    |       |
|   m   | int(11)      | YES  |     | NULL    |       |
|   n   | bigint(20)   | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
5 rows in set (0.00 sec)
```

> TINYINT有符号数和无符号数的取值范围分别为-128~127和0~255，由于负号占了一个数字位，因此 TINYINT默认的显示宽度为4。同理，其他整数类型的默认显示宽度与其有符号数的最小值的宽度相同
>
> MEDIUMINT为无符号数时有8(数字位数)+1(符号)位，因此为9
>
> BIGINT没有无符号数，因此为20

##### UNSIGNED

**UNSIGNED**: `无符号类型`（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。

##### ZEROFILL

**ZEROFILL**: 0填充,（如果某列是ZEROFILL，那么MySQL会`自动为当前列添加UNSIGNED`属性），如果`指定了ZEROFILL`但是`表示不够M位时，用0在左边填充`，如果`超过M位`，只要`不超过数据存储范围即可`。

原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。int(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。也就是说，**int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义**。如果整数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充

```mysql
CREATE TABLE test_int2(
f1 INT,
f2 INT(5),
f3 INT(5) ZEROFILL
)

INSERT INTO test_int2(f1,f2,f3)
VALUES(1,123,123);
INSERT INTO test_int2(f1,f2)
VALUES(123456,123456);
INSERT INTO test_int2(f1,f2,f3)
VALUES(123456,123456,123456);

mysql> SELECT * FROM test_int2;
+--------+--------+--------+
|   f1   |   f2   |   f3   |
+--------+--------+--------+
|    1   |   123  |  00123 |
| 123456 | 123456 |   NULL |
| 123456 | 123456 | 123456 |
+--------+--------+--------+
3 rows in set (0.00 sec)

```



#### 适用场景

**TINYINT**：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。

**SMALLINT**：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。

**MEDIUMINT**：用于较大整数的计算，比如车站每日的客流量等。

**INT、INTEGER**：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。

**BIGINT**：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。

#### 如何选择

在评估用哪种整数类型的时候，需要考虑`存储空间`和`可靠性`的平衡问题：一方面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间，使用的整数类型取值范围太小，一 旦遇到超出取值范围的情况，就可能引起`系统错误`，影响可靠性。

举个例子，商品编号采用的数据类型是INT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累

如果使用SMALLINT类型，虽然占用字节数比INT类型的整数少，但是却不能保证数据不会超出范围65535。相反，使用INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题

需要注意的是，在实际工作中，**系统故障产生的成本远远超过增加几个字段存储空间所产生的成本**。因此，建议**首先确保数据不会超过取值范围**，在这个前提之下，再去考虑如何节省存储空间

### <a id="浮点类型">浮点类型</a>

#### 类型介绍

浮点数和定点数类型的特点是可以`处理小数`，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。MySQL支持的浮点数类型，分别是FLOAT、DOUBLE、REAL

- **FLOAT**：表示单精度浮点数，占用4字节；

- **DOUBLE**：表示双精度浮点数，占用8字节；

- **REAL**：`默认`就是`DOUBLE`。如果把SQL模式设定为启用`REAL_AS_FLOAT`，那么，MySQL就认为REAL是FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：

  ```mysql
  SET sql_mode = "REAL_AS_FLOAT";
  ```

**问题：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于 有符号数取值范围大于等于零的部分呢？**

MySQL存储浮点数的格式为：`符号(S)`、`尾数(M)`和`阶码(E)`。因此，无论有没有符号，MySQL 的浮点数都会存储表示符号的部分。因此，**所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分**

#### 数据精度说明

对于浮点类型，在MySQL中单精度值使用`4`个字节，双精度值使用`8`个字节。

- MySQL允许使用`非标准语法`（其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用）：**FLOAT(M,D)**或**DOUBLE(M,D)** 。这里，**M**称为`精度` ，**D**称为`标度`。(M,D)中：**M=整数位+小数位**，**D=小数位**。**D<=M<=255**，**0<=D<=30**。

  例如：定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。如果超过这个范围会报错。

- FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示。

- 说明：浮点类型，也可以加`UNSIGNED`，但是`不会改变数据范围`，例如：FLOAT(3,2) UNSIGNED仍然 只能表示0-9.99的范围。

- 不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：

  - **如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值**
  - 如果存储时，小数点部分若超出范围，就分以下情况：
    - 若**四舍五入后，整数部分没有超出范围，则只警告**，但能成功操作并四舍五入删除多余 的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。
    - 若**四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理**。如FLOAT(5,2)列内插入 999.995和-999.995都会报错。

- **从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用**，将来可能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。

#### 精度误差说明

浮点数类型有个缺陷，就是不精准。下面解释一下为什么 MySQL 的浮点数不够精准。比如，我们设计一个表，有f1这个字段，插入值分别为0.47,0.44,0.19，我们期待的运行结果是：0.47 + 0.44 + 0.19 = 1.1。而使用sum之后查询：

```mysql
CREATE TABLE test_double2(
f1 DOUBLE
);

INSERT INTO test_double2
VALUES(0.47),(0.44),(0.19);

mysql> SELECT SUM(f1)
-> FROM test_double2;
+--------------------+
|       SUM(f1)      |
+--------------------+
| 1.0999999999999999 |
+--------------------+
1 row in set (0.00 sec)
```

查询结果是 1.0999999999999999。看到了吗？虽然误差很小，但确实有误差。 也可以尝试把数据类型改成 FLOAT，然后运行求和查询，得到的是，1.0999999940395355。显然，误差更大了。

那么，为什么会存在这样的误差呢？问题还是出在 MySQL 对浮点类型数据的存储方式上。

MySQL用4个字节存储 FLOAT 类型数据，用8个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二进制的方式来进行存储的。比如9.625，用二进制来表达，就是 1001.101，或者表达成1.001101×2^3。**如果尾数不是0或5（比如 9.624），就无法用一个二进制数来精确表达**。进而，就只好在取值允许的范围内进行四舍五入。

在编程中，如果用到浮点数，要特别注意误差问题，因为**浮点数是不准确的，所以要避免使用“=”来 判断两个数是否相等**。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成 不可挽回的损失。MySQL有精准的数据类型：定点数类型：**DECIMAL** 

### <a id="定点数类型">定点数类型</a>

#### 类型介绍

- MySQL中的定点数类型只有DECIMAL`一种`类型。

| 类型                     | 字节    | 有符号数取值范围   |
| ------------------------ | ------- | ------------------ |
| DECIMAL(M,D),DEC,NUMERIC | M+2字节 | 有效范围由M和D决定 |

使用**DECIMAL(M,D)**的方式表示高精度小数。其中，M被称为精度，D被称为标度。**0<=M<=65**，**0<=D<=30**，**D<M**。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99

- **DECIMAL(M,D)的最大取值范围与DOUBLE类型一样**，但是有效的数据范围是由M和D决定的。 DECIMAL的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些
- 定点数在MySQL内部是以`字符串`的形式进行存储，这就决定了它一定是精准的
- 当DECIMAL类型不指定精度和标度时，其`默认为DECIMAL(10,0)`。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行**四舍五入**处理
- **浮点数 vs 定点数**
  - 浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）
  - 定点数类型`取值范围相对小，但是精准，没有误差`，适合于对精度要求极高的场景 （比如涉及金额计算的场景）

#### 开发中经验

“由于DECIMAL数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。” ——来自某项目经理

### <a id="位类型">位类型:BIT</a>

BIT类型中存储的是二进制值，类似010110。

| 二进制字符串类型 | 长度 | 长度范围     | 占用空间            |
| ---------------- | ---- | ------------ | ------------------- |
| BIT(M)           | M    | 1 <= M <= 64 | 约为(M + 7)/8个字节 |

**BIT**类型，如果没有指定(M)，`默认是1位`。这个1位，表示只能存1位的二进制值。这里(M)是表示`二进制的位数`，位数`最小值为1`，`最大值为64`

- 在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内
- 使用SELECT命令查询位字段时，可以用`BIN()`或`HEX()`函数进行读取
- 查询10进制可以使用`bit+0`查询

### <a id="日期时间类型">日期时间类型</a>

日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签，从而进行数据查询、统计和处理。

MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。

- **YEAR**类型通常用来表示`年`
- **DATE**类型通常用来表示`年、月、日`
- **TIME**类型通常用来表示`时、分、秒`
- **DATETIME**类型通常用来表示`年、月、日、时、分、秒`
- **TIMESTAMP**类型通常用来表示`带时区的年、月、日、时、分、秒`

| 类型                    | 名称     | 字节 | 日期格式                  | 最小值                        | 最大值                       |
| ----------------------- | -------- | ---- | ------------------------- | ----------------------------- | ---------------------------- |
| [YEAR](#year)           | 年       | 1    | YYYY或YY                  | 1901                          | 2155                         |
| [TIME](#time)           | 时间     | 3    | HH:MM:SS                  | -838:59:59                    | 838:59:59                    |
| [DATE](#date)           | 日期     | 3    | YYYY-MM-DD                | 1000-01-01                    | 9999-12-03                   |
| [DATETIME](#datetime)   | 日期时间 | 8    | YYYY-MM-DD <br />HH:MM:SS | 1000-01-01 <br />00:00:00     | 9999-12-31 <br />23:59:59    |
| [TIMESTAMP](#timestamp) | 日期时间 | 4    | YYYY-MM-DD <br />HH:MM:SS | 1970-01-01 <br />00:00:00 UTC | 2038-01-19 <br />03:14:07UTC |

可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，要根据实际需要灵活选取。

为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？原因是 MySQL 设计的 TIME 类型，不光表示一天之内的时间，而且可以用来表示一个`时间间隔`，这个时间间隔可以超过 24 小时

#### <a id="year">YEAR</a>

**YEAR**类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要`1个字节`的存储空间

在MySQL中，YEAR有以下几种存储格式：

- 以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。
- 以2位字符串格式表示YEAR类型，最小值为00，最大值为99。
  - 当取值为01到69时，表示2001到2069
  - 当取值为70到99时，表示1970到1999
  - 当取值整数的0或00添加的话，那么是0000年
  - 当取值是日期/字符串的'0'添加的话，是2000年

**从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用**。YEAR`默认格式就是“YYYY”`，没必要写成YEAR(4)
从MySQL 8.0.19开始，不推荐使用指定显示宽度的YEAR(4)数据类型

#### <a id="date">DATE</a>

**DATE**类型表示日期，`没有时间部分`，格式为`YYYY-MM-DD`，其中，YYYY表示年份，MM表示月份，DD表示日期。需要`3个字节`的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件

- 以`YYYY-MM-DD`格式或者`YYYYMMDD`格式表示的字符串日期，其最小取值为1000-01-01，最大取值为 9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式
- 以`YY-MM-DD`格式或者`YYMMDD`格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99 时，会被转化为1970到1999
- 使用`CURRENT_DATE()`或者`NOW()`函数，会插入当前系统的日期

#### <a id="time">TIME</a>

**TIME**类型用来表示时间，`不包含日期部分`。在MySQL中，需要`3个字节`的存储空间来存储TIME类型的数据，可以使用`HH:MM:SS`格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒

在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式：

- 可以使用带有冒号的字符串，比如`D HH:MM:SS`、`HH:MM:SS`、`HH:MM`、`D HH:MM`、`D HH`或`SS`格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10
- 可以使用不带有冒号的 字符串或者数字，格式为`HHMMSS`或者`HHMMSS`。如果插入一个`不合法的字符串或者数字`，MySQL在存储数据时，会将其`自动转化为00:00:00`进行存储。比如1210，MySQL会将`最右边的两位解析成秒`，表示 00:12:10，而不是12:10:00
- 使用`CURRENT_TIME()`或者`NOW()`，会插入当前系统的时间

#### <a id="datetime">DATETIME</a>

**DATETIME**类型在所有的日期时间类型中占用的存储空间最大，总共需要`8个字节`的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为`YYYY-MM-DD HH:MM:SS`，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。

在向DATETIME类型的字段插入数据时，需要满足一定的格式条件：

- 以`YYYY-MM-DD HH:MM:SS`格式或者`YYYYMMDDHHMMSS`格式的字符串插入DATETIME类型的字段时， 最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59
  - 以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式
- 以`YY-MM-DD HH:MM:SS`格式或者`YYMMDDHHMMSS`格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。
- 使用函数`CURRENT_TIMESTAMP()`和`NOW()`，可以向DATETIME类型的字段插入系统的当前日期和时间。

#### <a id="timestamp">TIMESTAMP</a>

**TIMESTAMP**类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是`YYYY-MM-DD HH:MM:SS`，需要`4个字节`的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间

- **存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间**

- 向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。

- 如果向TIMESTAMP类型的字段插入的时间`超出`了TIMESTAMP类型的范围，则MySQL会`抛出错误信息`

#### TIMESTAMP和DATETIME的区别

- TIMESTAMP存储空间比较小，表示的日期时间范围也比较小 底层存储方式不同，
- TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。
- 两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。
- TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的

#### 开发中经验

用得**最多**的日期时间类型，就是**DATETIME**。虽然 MySQL 也支持YEAR（年）、TIME（时间）、DATE（日期），以及TIMESTAMP类型，但是在实际项目中，尽量用DATETIME类型。因为这个数据类型`包括了完整的日期和时间信息`，`取值范围也最大`，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL语句也会更加复杂。

此外，一般存`注册时间、商品发布时间等`，不建议使用DATETIME存储，而是使用**时间戳** ，因为DATETIME虽然直观，但不便于计算

### <a id="文本字符串类型">文本字符串类型</a>

MySQL中，文本字符串总体上分为CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET等类型

| 类型       | 长度 | 范围(字节)   | 占用             |
| ---------- | :--- | ------------ | ---------------- |
| CHAR(M)    | M    | 0~255        | M个字符          |
| VARCHAR(M) | M    | 0~65535      | M+1个字符        |
| TINYTEXT   | L    | 0~255        | L+2个字符        |
| TEXT       | L    | 0~65536      | L+2个字符        |
| MEDIUMTEXT | L    | 0~16777215   | L+3个字符        |
| LONGTEXT   | L    | 0~4294967295 | L+4个字符        |
| ENUM       | L    | 1~65536      | 1或2个字符       |
| SET        | L    | 0~64         | 1,2,3,4或8个字符 |

#### CHAR与VARCHAR

CHAR和VARCHAR类型都可以存储比较短的字符串

| 类型       | 特点     | 长度 | 范围(字节) | 占用               |
| ---------- | -------- | ---- | ---------- | ------------------ |
| CHAR(M)    | 固定长度 | M    | 0~255      | M个字符            |
| VARCHAR(M) | 可变长度 | M    | 0~65535    | (实际长度+1)个字符 |

**MySQL4.0版本以下，CHAR/VARCHAR(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字 节）；MySQL5.0版本以上，CHAR/VARCHAR(20)：指的是20字符**

##### CHAR

- CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度`默认是1个字符`
- 如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在`右侧填充`空格以达到指定的长度。当MySQL`检索`CHAR类型的数据时，CHAR类型的字段会`去除尾部的空格`
- 定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数

##### VARCHAR

- VARCHAR(M)定义时，`必须指定`长度M，否则报错
- 检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节

##### 对比

| 类型       | 特点     | 空间上       | 时间上 | 适用场景             |
| ---------- | -------- | ------------ | ------ | -------------------- |
| CHAR(M)    | 固定长度 | 浪费存储空间 | 效率高 | 存储不大，速度要求高 |
| VARCHAR(M) | 可变长度 | 节省存储空间 | 效率低 | 非CHAR的情况         |

情况1：存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失

情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息

情况3：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的

情况4：具体存储引擎中的情况：

- **MyISAM**数据存储引擎和数据列：MyISAM数据表，`最好使用固定长度(CHAR)`的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使`数据检索更快`，用空间换时间
- **MEMORY**存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都`没有关系`，两者都是作为CHAR类型处理的。 
- **InnoDB**存储引擎，`建议使用VARCHAR类型`。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且**主要影响性能的因素是数据行使用的存储总量**，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好

#### TEXT

在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT类型

在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和 VARCHAR类型相同

每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：

| 类型       | 特点               | 长度 | 范围                          | 占用    |
| ---------- | ------------------ | ---- | ----------------------------- | ------- |
| TINYTEXT   | 小文本，可变长度   | L    | 0~255                         | L+2字节 |
| TEXT       | 文本，可变长度     | L    | 0~65535                       | L+2字节 |
| MEDIUMTEXT | 中等文本，可变长度 | L    | 0~16777215                    | L+3字节 |
| LONGTEXT   | 大文本，可变长度   | L    | 0~4294967295<br />(相当于4GB) | L+4字节 |

`在保存和查询数据时，并没有删除TEXT类型的数据尾部的空格`

**由于实际存储的长度不确定，MySQL 不允许TEXT类型的字段做主键**。遇到这种情况，你只能采用CHAR(M)，或者VARCHAR(M)

**开发中经验：**

TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表

#### <a id="枚举类型">ENUM类型</a>

ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM 类型只允许从成员中选取单个值，不能一次选取多个值。

其所需要的存储空间由定义ENUM类型时指定的成员个数决定

| 类型 | 长度 | 范围    | 占用     |
| ---- | ---- | ------- | -------- |
| ENUM | L    | 1~65535 | 1或2字节 |

- 当ENUM类型包含1～255个成员时，需要1个字节的存储空间
- 当ENUM类型包含256～65535个成员时，需要2个字节的存储空间
- ENUM类型的成员个数的上限为65535个

```MySQL
CREATE TABLE test_enum(
season ENUM('春','夏','秋','冬','unknow')
);

INSERT INTO test_enum
VALUES('春'),('秋');

# 忽略大小写
INSERT INTO test_enum
VALUES('UNKNOW');

# 允许按照角标的方式获取指定索引位置的枚举值
# '1'相当于春，3相当于秋
INSERT INTO test_enum
VALUES('1'),(3);

# Data truncated for column 'season' at row 1
INSERT INTO test_enum
VALUES('ab');

# 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的
INSERT INTO test_enum
VALUES(NULL)
```

#### <a id="集合类型">SET类型</a>

SET表示一个字符串对象，`可以包含0个或多个成员`，但成员个数的上限为`64`。设置字段值时，可以取取值范围内的 0 个或多个值。

当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：

| 成员个数范围（L表示实际成员个数） | 占用的存储空间 |
| --------------------------------- | -------------- |
| 1 <= L <= 8                       | 1个字节        |
| 9 <= L <= 16                      | 2个字节        |
| 17 <= L <= 24                     | 3个字节        |
| 25 <= L <= 32                     | 4个字节        |
| 33 <= L <= 64                     | 8个字节        |

SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同

```MySQL
CREATE TABLE test_set(
s SET ('A', 'B', 'C')
);

INSERT INTO test_set (s) VALUES ('A'), ('A,B');

#插入重复的SET类型成员时，MySQL会自动删除重复的成员
INSERT INTO test_set (s) VALUES ('A,B,C,A');

#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。
INSERT INTO test_set (s) VALUES ('A,B,C,D');
```

### <a id="二进制字符串类型">二进制字符串类型</a>

MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据

MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB类型

#### BINARY与VARBINARY

BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。 

**BINARY(M)**为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储`1个字节`。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充'\0'以补齐指定长度

**VARBINARY(M)**为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型`必须指定(M)`，否则报错

| 类型         | 特点     | 长度    | 占用      |
| ------------ | -------- | ------- | --------- |
| BINARY(M)    | 固定长度 | 0~255   | M个字节   |
| VARBINARY(M) | 可变长度 | 0~65535 | M+1个字节 |

```mysql
CREATE TABLE test_binary1(
f1 BINARY,
f2 BINARY(3),
# f3 VARBINARY,
f4 VARBINARY(10)
);

INSERT INTO test_binary1(f1,f2)
VALUES('a','a');
INSERT INTO test_binary1(f1,f2)
VALUES('尚','尚');#失败

INSERT INTO test_binary1(f2,f4)
VALUES('ab','ab');
mysql> SELECT LENGTH(f2),LENGTH(f4)
-> FROM test_binary1;
+------------+------------+
| LENGTH(f2) | LENGTH(f4) |
+------------+------------+
|      3     |     NULL   |
|      3     |      2     |
+------------+------------+
2 rows in set (0.00 sec)
```

#### BLOB类型

BLOB是一个`二进制大对象`，可以容纳可变数量的数据

MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如`图片`、`音频`和`视频`等

在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图 片、音频和视频文件存储到`服务器的磁盘上`，并将图片、音频和视频的访问路径存储到MySQL中

| 类型       | 长度 | 范围         | 占用    |
| ---------- | ---- | ------------ | ------- |
| TINYBLOB   | L    | 0~255        | L+1字节 |
| BLOB       | L    | 0~65535      | L+2字节 |
| MEDIUMBLOB | L    | 0~16777215   | L+3字节 |
| LONGBLOB   | L    | 0~4294967295 | L+4字节 |

**TEXT和BLOB的使用注意事项：**

在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能

- BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的`空洞`，以后填入这些"空洞"的记录可能长度不同。为了提高性能，建议定期使用**OPTIMIZE TABLE**功能对这类表进行`碎片整理`
- 如果需要对大文本字段进行模糊查询，MySQL提供了`前缀索引`。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值
- 把BLOB或TEXT列`分离到单独的表`中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会`减少主表中的碎片`，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值

### <a id="JSON类型">JSON类型</a>

JSON（JavaScript Object Notation）是一种轻量级的`数据交换格式`。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。**JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式**

在MySQL5.7中，就已经支持JSON数据类型。在MySQL8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。 创建数据表，表中包含一个JSON类型的字段js

```mysql
CREATE TABLE test_json(
	js json
);

INSERT INTO test_json (js)
VALUES ('{"name":"songhk", "age":18, "address":{"province":"beijing",
"city":"beijing"}}');
```

当需要检索JSON类型的字段中数据的某个具体值时，可以使用“->”和“->>”符号

```mysql
mysql> SELECT js -> '$.name' AS NAME,js -> '$.age' AS age ,js -> '$.address.province'AS province, js -> '$.address.city' AS city
-> FROM test_json;
+----------+------+-----------+-----------+
|   NAME   |  age |  province |    city   |
+----------+------+-----------+-----------+
| "songhk" |   18 | "beijing" | "beijing" |
+----------+------+-----------+-----------+
1 row in set (0.00 sec)
```

通过“->”和“->>”符号，从JSON字段中正确查询出了指定的JSON数据的值

### <a id="空间数据类型">空间数据类型</a>

MySQL 空间类型扩展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东 西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如 一个十字路口等等。MySQL中使用`Geometry（几何）`来表示所有地理特征。Geometry指一个点或点的集合，代表世界上任何具有位置的事物。

MySQL的空间数据类型（Spatial Data Type）对应于OpenGIS类，包括单值类型：GEOMETRY、POINT、LINESTRING、POLYGON以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION4

- Geometry是所有空间集合类型的基类，其他类型如POINT、LINESTRING、POLYGON都是Geometry的子类
  - **Point**，顾名思义就是点，有一个坐标值。例如POINT(121.213342 31.234532)，POINT(30 10)， 坐标值支持DECIMAL类型，经度（longitude）在前，维度（latitude）在后，`用空格分隔`
  - **LineString**，线，由一系列点连接而成。如果线从头至尾没有交叉，那就是简单的 （simple）；如果起点和终点重叠，那就是封闭的（closed）。例如LINESTRING(30 10,10 30,40 40)，点与点之间用逗号分隔，一个点中的经纬度用空格分隔，与POINT格式一致
  - **Polygon**，多边形。可以是一个实心平面形，即没有内部边界，也可以有空洞，类似纽扣。最简单的就是只有一个外边界的情况，例如POLYGON((0 0,10 0,10 10, 0 10))。

下面展示几种常见的几何图形元素：

![image-20221023171926913](https://cdn.jsdelivr.net/gh/6hqt9/TyporaNotes/img/mysql_geometryprimitives.png)

- MultiPoint、MultiLineString、MultiPolygon、GeometryCollection 这4种类型都是集合类，是多个 Point、LineString或Polygon组合而成

下面展示的是多个同类或异类几何图形元素的组合：

 ![image-20221023172343452](https://cdn.jsdelivr.net/gh/6hqt9/TyporaNotes/img/mysql_multipartgeometries.png)

### 小结与建议

在定义数据类型时，如果确定是`整数`，就用**INT**； 如果是`小数`，一定用定点数类型 **DECIMAL(M,D)**； 如果是`日期与时间`，就用**DATETIME**

这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT虽然使用方便，但是效率不如CHAR(M)和 VARCHAR(M)。关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：

**阿里巴巴《Java开发手册》之MySQL数据库：**

- 任何字段如果为非负数，必须是UNSIGNED
- 【`强制`】`小数类型`为**DECIMAL**，禁止使用FLOAT和DOUBLE
  - 说明：在存储的时候，FLOAT和DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。`如果存储的数据范围超过DECIMAL的范围，建议将数据拆成整数和小数并分开存储`
- 【`强制`】如果存储的`字符串长度几乎相等`，使用**CHAR**定长字符串类型
- 【`强制`】**VARCHAR**是可变长字符串，不预先分配存储空间，`长度不要超过5000`。如果存储长度大于此值，定义字段类型为**TEXT**，独立出来一张表，用主键来对应，避免影响其它字段索引效率

## 运算符

### 运算符优先级

数字`编号越大，优先级越高`，优先级高的运算符先进行计算。可以看到，赋值运算符的优先级最低，使用`()`括起来的表达式的优先级最高

| 优先级 | 运算符                                               |
| ------ | ---------------------------------------------------- |
| 1      | :=，=(赋值)                                          |
| 2      | \|\|，OR，XOR                                        |
| 3      | &&，AND                                              |
| 4      | NOT                                                  |
| 5      | BETWEEN，CASE，WHEN，THEN，ELSE                      |
| 6      | =(比较)，<=>，>=，>，<，<=，!=，IS，LIKE，REGEXP，IN |
| 7      | \|                                                   |
| 8      | &                                                    |
| 9      | <<，>>                                               |
| 10     | -，+                                                 |
| 11     | *，/，DIV，%，MOD                                    |
| 12     | ^                                                    |
| 13     | -(负号)，~                                           |
| 14     | !                                                    |
| 15     | ()                                                   |



### 算数运算符

| 运算符 | 名称                   | 作用                     | 示例                             |
| :----: | ---------------------- | ------------------------ | -------------------------------- |
|   +    | [加法运算符](#+-)      | 计算两个值或表达式的和   | SELECT A + B                     |
|   -    | [减法运算符](#+-)      | 计算两个值或表达式的差   | SELECT A - B                     |
|   *    | [乘法运算符](#*/)      | 计算两个值或表达式的积   | SELECT A * B                     |
| /或DIV | [除法运算符](#*/)      | 计算两个值或表达式的商   | SELECT A / B<br />SELECT A DIV B |
| %或MOD | [求模(求余)运算符](#%) | 计算两个值或表达式的余数 | SELECT A % B<br />SELECT A MOD B |

- <a id="+-">加法与减法</a>
  - 一个`整数类型`的值对`整数`进行加法和减法操作，结果还是一个`整数`；
  - 一个`整数类型`的值对`浮点数`进行加法和减法操作，结果是一个`浮点数`；
  - 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；
  - 在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中`+只表示数值相加`。如果遇到非数值类型，先`尝试转成数值`，如果转`失败`，就`按0计算`。（补充：MySQL 中字符串拼接要使用字符串函数CONCAT()实现）

```mysql
mysql> SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5
FROM dual;
+-----+---------+---------+----------+--------------+------------+------------+
| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 |
+-----+---------+---------+----------+--------------+------------+------------+
| 100 |      100|     100 |      150 |          120 |      135.5 |       64.5 |
+-----+---------+---------+----------+--------------+------------+------------+
1 row in set (0.00 sec)
```

- <a id="*/">乘法与除法</a>
  - 一个数乘以整数1和除以整数1后仍得原数；
  - 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；
  - 一个数`除`以整数后，不管是否能除尽，`结果都为一个浮点数`；
  - 一个数除以另一个数，`除不尽`时，结果为一个浮点数，并`保留到小数点后4位`；
  - 乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。 在数学运算中，0不能用作除数，在MySQL中，`一个数除以0为NULL`

```mysql
mysql> SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,100 + 2 * 5 / 2,100 /3, 100
DIV 0 FROM dual;
+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+
| 100 | 100 * 1 | 100 * 1.0 | 100 / 1.0 | 100 / 2 | 100 + 2 * 5 / 2 |  100 /3 |  100DIV 0 |
+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+
| 100 |   100   |   100.0   |  100.0000 | 50.0000 |    105.0000     | 33.3333 |    NULL   |
+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+
1 row in set (0.00 sec)

```

- <a id="%">求模(求余)运算符</a>

  结果`符号只与分母有关`

### 比较运算符

- 比较的结果为`真则返回1`，比较的结果为`假返回0`，`其他`情况则`返回NULL`
- 一般用于SELECT查询条件进行筛选

| 运算符 | 名称             | 作用                                                         | 示例                                                         |
| :----: | :--------------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
|   =    | [等于](#=)       | 判断两个值、字符串或表达式<br />是否相等                     | SELECT C FROM TABLE WHERE A = B                              |
|  <=>   | [安全等于](#aq=) | 安全的判断两个值、字符串或表达式<br />是否相等               | SELECT C FROM TABLE WHERE A <=> B                            |
| <>(!=) | [不等于](#!=)    | 判断两个值、字符串或表达式<br />是否不相等                   | SELECT C FROM TABLE WHERE A <> B<br />SELECT C FROM TABLE WHERE A != B |
|   <    | 小于             | 判断前面的值、字符串或表达式是否<br />小于后面的值、字符串或表达式 | SELECT C FROM TABLE WHERE A < B                              |
|   <=   | 小于等于         | 判断前面的值、字符串或表达式是否<br />小于等于后面的值、字符串或表达式 | SELECT C FROM TABLE WHERE A <= B                             |
|   >    | 大于             | 判断前面的值、字符串或表达式是否<br />大于后面的值、字符串或表达式 | SELECT C FROM TABLE WHERE A > B                              |
|   >=   | 大于等于         | 判断前面的值、字符串或表达式是否<br />大于等于后面的值、字符串或表达式 | SELECT C FROM TABLE WHERE A >= B                             |

> 当使用数字与字符串比较时，字符串会截取最前面的数字作为字符串的值进行比较，如果最前面没有数字，则字符串的值当作0

- <a id="=">等于</a>

  - 如果等号两边的值、字符串或表达式`都为字符串`，则MySQL会按照`字符串进行比较`，其比较的是每个字符串中字符的ANSI编码是否相等
  - 如果等号两边的值都是`整数`，则MySQL会按照整数来比较两个`值`的大小
  - 如果等号两边的值`一个是整数`，另一个是`字符串`，则MySQL会将`字符串转化为数字`进行比较
  - 如果等号两边的值、字符串或表达式中`有一个为NULL`，则比较`结果为NULL`

- <a id="aq=">安全等于</a>

  与等于的区别：`可以用来对NULL进行判断`。在两个操作数`均为NULL`时，其返回值为`1`，而不为NULL；当`一个`操作数`为NULL` 时，其返回值为`0`，而不为NULL

- <a id="!=">不等于</a>

  判断两边的数字、字符串或者表达式的值是否不相等， 如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有`任意一个为NULL`， 或`两边都为NULL`，则`结果为NULL`

### 非符号运算符

|   运算符    | 名称                          | 作用                               | 示例                                          |
| :---------: | ----------------------------- | ---------------------------------- | --------------------------------------------- |
|   IS NULL   | [为空运算符](#isnull)         | 判断值、字符串或表达式是否为空     | SELECT B FROM TABLE WHERE A IS NULL           |
| IS NOTNULL  | [不为空运算符](#isnotnull)    | 判断值、字符串或表达式是否不为空   | SELECT B FROM TABLE WHERE A IS NOT NULL       |
|   ISNULL    | [为空运算符](#isnull)         | 判断一个值、字符串或表达式是否为空 | SELECT B FROM TABLE WHERE ISNULL(A)           |
|    LEAST    | [最小值运算符](#least)        | 多个值中返回最小值                 | SELECT D FROM TABLE WHERE C LEAST(A,B,...)    |
|  GREATEST   | [最大值运算符](#greatest)     | 多个值中返回最大值                 | SELECT D FROM TABLE WHERE C GREATEST(A,B,...) |
| BETWEEN AND | [两值之间运算符](#betweenand) | 判断一个值是否在两值之间           | SELECT D FROM TABLE WHERE C BETWEEN A AND B   |
|     IN      | [属于运算符](#in)             | 判断一个值是否为列表中任意一值     | SELECT D FROM TABLE WHERE C IN(A,B)           |
|   NOT IN    | [不属于运算符](#notin)        | 判断一个值是否不是列表中任意一值   | SELECT D FROM TABLE WHERE C NOT IN(A,B)       |
|    LIKE     | [模糊匹配运算符](#like)       | 判断一个值是否符合模糊匹配规则     | SELECT C FROM TABLE WHERE A LIKE B            |
|   REGEXP    | [正则表达式运算符](#regexp)   | 判断一个值是否符合正则表达式的规则 | SELECT C FROM TABLE WHERE A REGEXP B          |
|    RLIKE    | 正则表达式运算符              | 判断一个值是否符合正则表达式的规则 | SELECT C FROM TABLE WHERE A RLIKE B           |

- <a id="isnull">空运算符</a>

  判断一个值是否为NULL，如果为NULL则返回1，否则返回 0

```mysql
#查询commission_pct等于NULL。比较如下的四种写法
SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL;
SELECT employee_id,commission_pct FROM employees WHERE commission_pct <=> NULL;
SELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct);
SELECT employee_id,commission_pct FROM employees WHERE commission_pct = NULL;
```

- <a id="isnotnull">非空运算符</a>

  判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0

```mysql
mysql> SELECT NULL IS NOT NULL, 'a' IS NOT NULL, 1 IS NOT NULL;
+------------------+-----------------+---------------+
| NULL IS NOT NULL | 'a' IS NOT NULL | 1 IS NOT NULL |
+------------------+-----------------+---------------+
|                0 |               1 |             1 |
+------------------+-----------------+---------------+
1 row in set (0.01 sec)

#查询commission_pct不等于NULL
SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NOT NULL;
SELECT employee_id,commission_pct FROM employees WHERE NOT commission_pct <=> NULL;
SELECT employee_id,commission_pct FROM employees WHERE NOT ISNULL(commission_pct);

# ISNULL可以有两个参数，第一个是原来值，第二个是替换的NULL值
```

- <a id="least">最小值运算符</a>

  语法格式为：`LEAST(值1，值2，...，值n)`。其中，“值n”表示参数列表中有n个值。在有 两个或多个参数的情况下，返回最小值

```mysql
mysql> SELECT LEAST (1,0,2), LEAST('b','a','c'), LEAST(1,NULL,2);
+---------------+--------------------+-----------------+
| LEAST (1,0,2) | LEAST('b','a','c') | LEAST(1,NULL,2) |
+---------------+--------------------+-----------------+
|             0 |                  a |            NULL |
+---------------+--------------------+-----------------+
1 row in set (0.00 sec)
```

> 当参数是`整数或者浮点数`时，LEAST将返回其中`最小的值`；当参数为`字符串`时，返回`字母表中顺序最靠前的字符`；当比较值列表中`有NULL`时，不能判断大小，返回值为`NULL`

- <a id="greatest">最大值运算符</a>

  语法格式为：`GREATEST(值1，值2，...，值n)`。其中，n表示参数列表中有n个值。当有 两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL

```mysql
mysql> SELECT GREATEST(1,0,2), GREATEST('b','a','c'), GREATEST(1,NULL,2);
+-----------------+-----------------------+--------------------+
| GREATEST(1,0,2) | GREATEST('b','a','c') | GREATEST(1,NULL,2) |
+-----------------+-----------------------+--------------------+
|               2 |                     c |               NULL |
+-----------------+-----------------------+--------------------+
1 row in set (0.00 sec)
```

> 当参数是`整数或者浮点数`时，LEAST将返回其中`最大的值`；当参数为`字符串`时，返回`字母表中顺序最靠后的字符`；当比较值列表中`有NULL`时，不能判断大小，返回值为`NULL`

- <a id="betweenand">BETWEEN AND运算符</a>

  BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0

  查询时，必须保证A小于B，才能查询到结果

```mysql
mysql> SELECT 1 BETWEEN 0 AND 1, 10 BETWEEN 11 AND 12, 'b' BETWEEN 'a' AND 'c';
+-------------------+----------------------+-------------------------+
| 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | 'b' BETWEEN 'a' AND 'c' |
+-------------------+----------------------+-------------------------+
|                 1 |                    0 |                       1 |
+-------------------+----------------------+-------------------------+
1 row in set (0.00 sec)

SELECT last_name, salary
FROM employees
WHERE salary BETWEEN 2500 AND 3500;
```

- <a id="in">IN运算符</a>

  IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给 定的值为NULL，或者IN列表中存在NULL，则结果为NULL

```mysql
mysql> SELECT 'a' IN ('a','b','c'), 1 IN (2,3), NULL IN ('a','b'), 'a' IN ('a', NULL);
+----------------------+------------+-------------------+--------------------+
| 'a' IN ('a','b','c') | 1 IN (2,3) | NULL IN ('a','b') | 'a' IN ('a', NULL) |
+----------------------+------------+-------------------+--------------------+
|                    1 |          0 |              NULL |                  1 |
+----------------------+------------+-------------------+--------------------+
1 row in set (0.00 sec)

SELECT employee_id, last_name, salary, manager_id
FROM employees
WHERE manager_id IN (100, 101, 201);
```

- <a id="notin">NOT IN运算符</a>

  NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一 个值，则返回1，否则返回0

```mysql
mysql> SELECT 'a' NOT IN ('a','b','c'), 1 NOT IN (2,3);
+--------------------------+----------------+
| 'a' NOT IN ('a','b','c') | 1 NOT IN (2,3) |
+--------------------------+----------------+
|                        0 |              1 |
+--------------------------+----------------+
1 row in set (0.00 sec)
```

- <a id="like">LIKE运算符</a>

  LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回 0。如果给定的值或者匹配条件为NULL，则返回结果为NULL

  LIKE运算符通常使用如下**通配符**：

  - “`%`”：匹配`0个或多个`字符
  - “`_`”：只能匹配`一个`字符(可连续使用)

  > 如果想查询特殊符号，如`-`，或其他特殊符号，有如下两种方式：
  >
  > - 使用转义字符`\`(使用`\`可以省略`ESCAPE`)：
  >
  >   ```MySQL
  >   SELECT last_name
  >   FROM employees
  >   WHERE last_name LIKE '_\_a%';
  >   #查询第二个字符是'_'且第三个字符是'a'
  >   ```
  >
  > - 使用其他`特殊符号+ESCAPE`：
  >
  >   ```MySQL
  >   SELECT last_name
  >   FROM employees
  >   WHERE last_name LIKE '_$_a%' ESCAPE '$';
  >   #查询第二个字符是'_'且第三个字符是'a'
  >   ```

```mysql
mysql> SELECT NULL LIKE 'abc', 'abc' LIKE NULL;
+-----------------+-----------------+
| NULL LIKE 'abc' | 'abc' LIKE NULL |
+-----------------+-----------------+
|            NULL |            NULL |
+-----------------+-----------------+
1 row in set (0.00 sec)

SELECT first_name
FROM employees
WHERE first_name LIKE 'S%';

SELECT last_name
FROM employees
WHERE last_name LIKE '_o%';
```

- <a id="regexp">REGEXP运算符</a>

  REGEXP运算符用来匹配字符串，语法格式为：`expr REGEXP 匹配条件 `。如果`expr满足匹配条件`，返回`1`；如果`不满足`，则返回`0`。若expr或匹配条件任意一个为NULL，则结果为NULL

  REGEXP运算符在进行匹配时，常用的有下面几种通配符：

  1. `^`匹配以该字符后面的字符开头的字符串
  2. `$`匹配以该字符前面的字符结尾的字符串
  3. `.`匹配任何一个单字符
  4. `+`匹配前面的字符1次或多次
  5. `[...]`匹配在方括号内的任何字符
     例如，`[abc]`匹配“a”或“b”或“c”。为了命名字符的范围，使用一 个`-`。`[a-z]`匹配任何字母，而`[0-9]`匹配任何数字
  6. `[^]`匹配不在括号内的任何字符
  7. `*`匹配零个或多个在它前面的字符。例如，`x*`匹配任何数量的`x`字符，`[0-9]*`匹配任何数量的数字， 而`*`匹配任何数量的任何字符
  8. `字符串`(abc)，匹配包含指定的字符串(包含abc)
  9. `字符串{n}`，匹配字符串至少n次
  10. `字符串{n,m}`：匹配字符串至少n次，之多m次

```mysql
mysql> SELECT 'shkstart' REGEXP '^s', 'shkstart' REGEXP 't$', 'shkstart' REGEXP 'hk';
+------------------------+------------------------+-------------------------+
| 'shkstart' REGEXP '^s' | 'shkstart' REGEXP 't$' | 'shkstart' REGEXP 'hk'  |
+------------------------+------------------------+-------------------------+
|                      1 |                      1 |                       1 |
+------------------------+------------------------+-------------------------+
1 row in set (0.01 sec)

mysql> SELECT 'atguigu' REGEXP 'gu.gu', 'atguigu' REGEXP '[ab]';
+--------------------------+-------------------------+
| 'atguigu' REGEXP 'gu.gu' | 'atguigu' REGEXP '[ab]' |
+--------------------------+-------------------------+
|                        1 |                       1 |
+--------------------------+-------------------------+
1 row in set (0.00 sec)
```



### 逻辑运算符

逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL

|   运算符   |   作用   | 示例                               |
| :--------: | :------: | :--------------------------------- |
|  NOT 或 !  |  逻辑非  | SELECT NOT A                       |
| AND 或 &&  |  逻辑与  | SELECT A AND B<br />SELECT A && B  |
| OR 或 \|\| |  逻辑或  | SELECT A OR B<br />SELECT A \|\| B |
|    XOR     | 逻辑异或 | SELECT A XOR B                     |

- 逻辑非运算符

  当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为NULL时，返回NULL

```mysql
mysql> SELECT NOT 1, NOT 0, NOT(1+1), NOT !1, NOT NULL;
+-------+-------+----------+--------+----------+
| NOT 1 | NOT 0 | NOT(1+1) | NOT !1 | NOT NULL |
+-------+-------+----------+--------+----------+
|     0 |     1 |        0 |      1 |     NULL |
+-------+-------+----------+--------+----------+
1 row in set, 1 warning (0.00 sec)

SELECT last_name, job_id
FROM employees
WHERE job_id NOT IN ('IT_PROG', 'ST_CLERK', 'SA_REP');
```

- 逻辑与运算符

  当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL

```MYSQL
mysql> SELECT 1 AND -1, 0 AND 1, 0 AND NULL, 1 AND NULL;
+----------+---------+------------+------------+
| 1 AND -1 | 0 AND 1 | 0 AND NULL | 1 AND NULL |
+----------+---------+------------+------------+
| 1 | 0 | 0 | NULL |
+----------+---------+------------+------------+
1 row in set (0.00 sec)

SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE salary >=10000
AND job_id LIKE '%MAN%';
```

> OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于`AND的优先级高于OR`，因此先对AND两边的操作数进行操作，再与OR中的操作数结合

- 逻辑或运算符

  当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL

```mysql
mysql> SELECT 1 OR -1, 1 OR 0, 1 OR NULL, 0 || NULL, NULL || NULL;
+---------+--------+-----------+-----------+--------------+
| 1 OR -1 | 1 OR 0 | 1 OR NULL | 0 || NULL | NULL || NULL |
+---------+--------+-----------+-----------+--------------+
|       1 |      1 |         1 |      NULL |         NULL |
+---------+--------+-----------+-----------+--------------+
1 row in set, 2 warnings (0.00 sec)

#查询基本薪资不在9000-12000之间的员工编号和基本薪资
SELECT employee_id,salary FROM employees
WHERE NOT (salary >= 9000 AND salary <= 12000);

SELECT employee_id,salary FROM employees
WHERE salary <9000 OR salary > 12000;

SELECT employee_id,salary FROM employees
WHERE salary NOT BETWEEN 9000 AND 12000;

SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE salary >= 10000
OR job_id LIKE '%MAN%';
```

> OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于`AND的优先级高于OR`，因此先对AND两边的操作数进行操作，再与OR中的操作数结合

- 逻辑异或运算符

  当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。即不一样的或

```MySQL
mysql> SELECT 1 XOR -1, 1 XOR 0, 0 XOR 0, 1 XOR NULL, 1 XOR 1 XOR 1, 0 XOR 0 XOR 0;
+----------+---------+---------+------------+---------------+---------------+
| 1 XOR -1 | 1 XOR 0 | 0 XOR 0 | 1 XOR NULL | 1 XOR 1 XOR 1 | 0 XOR 0 XOR 0 |
+----------+---------+---------+------------+---------------+---------------+
|        0 |       1 |       0 |       NULL |             1 |             0 |
+----------+---------+---------+------------+---------------+---------------+
1 row in set (0.00 sec)

select last_name,department_id,salary
from employees
where department_id in (10,20) XOR salary > 8000;
```

### 位运算符

位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算， 最后将计算结果从二进制变回十进制数

| 运算符 | 作用            | 示例          |
| ------ | --------------- | ------------- |
| &      | 按位与(位AND)   | SELECT A & B  |
| \|     | 按位或(位OR)    | SELECT A \| B |
| ^      | 按位异或(位XOR) | SELECT A ^ B  |
| ~      | 按位取反        | SELECT ~ A    |
| >>     | 按位右移        | SELECT A >> 2 |
| <<     | 按位左移        | SELECT B << 2 |



## 函数

### 单行函数

**单行函数**：

- 操作数据对象
- 接受参数返回一个结果
- **只对一行进行变换**
- **每行返回一个结果**
- 可以嵌套
- 参数可以是一列或一个值

#### 数值函数

##### 基本函数

| 函数                | 用法                                                         |
| ------------------- | ------------------------------------------------------------ |
| ABS(x)              | 返回x的绝对值                                                |
| SIGN(X)             | 返回X的符号。正数返回1，负数返回-1，0返回0                   |
| PI()                | 返回圆周率的值                                               |
| CEIL(x)，CEILING(x) | 返回大于或等于某个值的最小整数                               |
| FLOOR(x)            | 返回小于或等于某个值的最大整数                               |
| LEAST(e1,e2,e3…)    | 返回列表中的最小值                                           |
| GREATEST(e1,e2,e3…) | 返回列表中的最大值                                           |
| MOD(x,y)            | 返回X除以Y后的余数                                           |
| RAND()              | 返回0~1的随机值                                              |
| RAND(x)             | 返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数 |
| ROUND(x)            | 返回一个对x的值进行四舍五入后，最接近于X的整数               |
| ROUND(x,y)          | 返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位 |
| TRUNCATE(x,y)       | 返回数字x截断为y位小数的结果                                 |
| SQRT(x)             | 返回x的平方根。当X的值为负数时，返回NULL                     |

##### 角度与弧度互转

| 函数       | 用法                                  |
| ---------- | ------------------------------------- |
| RADIANS(x) | 将角度转化为弧度，其中，参数x为角度值 |
| DEGREES(x) | 将弧度转化为角度，其中，参数x为弧度值 |

##### 三角函数

| 函数       | 用法                                                         |
| ---------- | ------------------------------------------------------------ |
| SIN(x)     | 返回x的正弦值，其中，参数x为弧度值                           |
| ASIN(x)    | 返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL |
| COS(x)     | 返回x的余弦值，其中，参数x为弧度值                           |
| ACOS(x)    | 返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL |
| TAN(x)     | 返回x的正切值，其中，参数x为弧度值                           |
| ATAN(x)    | 返回x的反正切值，即返回正切值为x的值                         |
| ATAN2(m,n) | 返回两个参数的反正切值                                       |
| COT(x)     | 返回x的余切值，其中，X为弧度值                               |

> ATAN2(M,N)函数返回两个参数的反正切值。 与ATAN(X)函数相比，ATAN2(M,N)需要两个参数，例如有两个 点point(x1,y1)和point(x2,y2)，使用ATAN(X)函数计算反正切值为ATAN((y2-y1)/(x2-x1))，使用ATAN2(M,N)计 算反正切值则为ATAN2(y2-y1,x2-x1)。由使用方式可以看出，当x2-x1等于0时，ATAN(X)函数会报错，而 ATAN2(M,N)函数则仍然可以计算

##### 指数对数

| 函数                 | 用法                                                 |
| -------------------- | ---------------------------------------------------- |
| POW(x,y)，POWER(X,Y) | 返回x的y次方                                         |
| EXP(X)               | 返回e的X次方，其中e是一个常数，2.718281828459045     |
| LN(X)，LOG(X)        | 返回以e为底的X的对数，当X <= 0 时，返回的结果为NULL  |
| LOG10(X)             | 返回以10为底的X的对数，当X <= 0 时，返回的结果为NULL |
| LOG2(X)              | 返回以2为底的X的对数，当X <= 0 时，返回NULL          |

##### 进制转换

| 函数          | 用法                     |
| ------------- | ------------------------ |
| BIN(x)        | 返回x的二进制编码        |
| HEX(x)        | 返回x的十六进制编码      |
| OCT(x)        | 返回x的八进制编码        |
| CONV(x,f1,f2) | 返回f1进制数变成f2进制数 |

#### 字符串函数

| 函数                              | 用法                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| ASCII(S)                          | 返回字符串S中的第一个字符的ASCII码值                         |
| CHAR_LENGTH(s)                    | 返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同           |
| LENGTH(s)                         | 返回字符串s的字节数，和字符集有关                            |
| CONCAT(s1,s2,......,sn)           | 连接s1,s2,......,sn为一个字符串                              |
| CONCAT_WS(x, s1,s2,......,sn)     | 同CONCAT(s1,s2,...)函数，但是每个字符串之间要加上x           |
| INSERT(str, idx, len, replacestr) | 将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr |
| REPLACE(str, a, b)                | 用字符串b替换字符串str中所有出现的字符串a                    |
| UPPER(s) 或 UCASE(s)              | 将字符串s的所有字母转成大写字母                              |
| LOWER(s) 或LCASE(s)               | 将字符串s的所有字母转成小写字母                              |
| LEFT(str,n)                       | 返回字符串str最左边的n个字符                                 |
| RIGHT(str,n)                      | 返回字符串str最右边的n个字符                                 |
| LPAD(str, len, pad)               | 用字符串pad对str最左边进行填充，直到str的长度为len个字符(右对齐) |
| RPAD(str ,len, pad)               | 用字符串pad对str最右边进行填充，直到str的长度为len个字符(左对齐) |
| LTRIM(s)                          | 去掉字符串s左侧的空格                                        |
| RTRIM(s)                          | 去掉字符串s右侧的空格                                        |
| TRIM(s)                           | 去掉字符串s开始与结尾的空格                                  |
| TRIM(s1 FROM s)                   | 去掉字符串s开始与结尾的s1                                    |
| TRIM(LEADING s1 FROM s)           | 去掉字符串s开始处的s1                                        |
| TRIM(TRAILING s1 FROM s)          | 去掉字符串s结尾处的s1                                        |
| REPEAT(str, n)                    | 返回str重复n次的结果                                         |
| SPACE(n)                          | 返回n个空格                                                  |
| STRCMP(s1,s2)                     | 比较字符串s1,s2的ASCII码值的大小                             |
| SUBSTR(s,index,len)               | 返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、 MID(s,n,len)相同 |
| LOCATE(substr,str)                | 返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0 |
| ELT(m,s1,s2,…,sn)                 | 返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn |
| FIELD(s,s1,s2,…,sn)               | 返回字符串s在字符串列表中第一次出现的位置                    |
| FIND_IN_SET(s1,s2)                | 返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串 |
| REVERSE(s)                        | 返回s反转后的字符串                                          |
| NULLIF(value1,value2)             | 比较两个字符串，如果value1与value2相等，则返回NULL，否则返回 value1 |

> **MySQL**中，字符串的位置是`从1开始`的

#### 日期与时间函数

##### 获取日期时间

| 函数                                                         | 用法                            |
| ------------------------------------------------------------ | ------------------------------- |
| **CURDATE()** ，CURRENT_DATE()                               | 返回当前日期，只包含年、 月、日 |
| **CURTIME()** ， CURRENT_TIME()                              | 返回当前时间，只包含时、 分、秒 |
| **NOW()** / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() / LOCALTIMESTAMP() | 返回当前系统日期和时间          |
| UTC_DATE()                                                   | 返回UTC（世界标准时间） 日期    |
| UTC_TIME()                                                   | 返回UTC（世界标准时间） 时间    |

##### 日期时间戳转换

| 函数                     | 用法                                                         |
| ------------------------ | ------------------------------------------------------------ |
| UNIX_TIMESTAMP()         | 以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() - >1634348884 |
| UNIX_TIMESTAMP(date)     | 将时间date以UNIX时间戳的形式返回。                           |
| FROM_UNIXTIME(timestamp) | 将UNIX时间戳的时间转换为普通格式的时间                       |

##### 月份星期星期数天数

| 函数                                     | 用法                                             |
| ---------------------------------------- | ------------------------------------------------ |
| YEAR(date) / MONTH(date) / DAY(date)     | 返回具体的日期值                                 |
| HOUR(time) / MINUTE(time) / SECOND(time) | 返回具体的时间值                                 |
| FROM_UNIXTIME(timestamp)                 | 将UNIX时间戳的时间转换为普通格式的时间           |
| MONTHNAME(date)                          | 返回月份：January，...                           |
| DAYNAME(date)                            | 返回星期几：MONDAY，TUESDAY.....SUNDAY           |
| WEEKDAY(date)                            | 返回周几，注意，周1是0，周2是1，。。。周日是6    |
| QUARTER(date)                            | 返回日期对应的季度，范围为1～4                   |
| WEEK(date) ， WEEKOFYEAR(date)           | 返回一年中的第几周                               |
| DAYOFYEAR(date)                          | 返回日期是一年中的第几天                         |
| DAYOFMONTH(date)                         | 返回日期位于所在月份的第几天                     |
| DAYOFWEEK(date)                          | 返回周几，注意：周日是1，周一是2，。。。周六是 7 |

##### 日期操作

| 函数                    | 用法                                       |
| ----------------------- | ------------------------------------------ |
| EXTRACT(type FROM date) | 返回指定日期中特定的部分，type指定返回的值 |

EXTRACT(type FROM date)函数中`type`的取值与含义：

| type取值           | 含义                         |
| ------------------ | ---------------------------- |
| MICROSECOND        | 返回毫秒数                   |
| SECOND             | 返回秒数                     |
| MINUTE             | 返回分钟数                   |
| HOUR               | 返回小时数                   |
| DAY                | 返回天数                     |
| WEEK               | 返回日期在一年中的第几个星期 |
| MONTH              | 返回日期在一年中的第几个月   |
| QUARTER            | 返回日期在一年中的第几个季度 |
| YEAR               | 返回日期的年份               |
| SECOND_MICORSECOND | 返回秒和毫秒值               |
| MINUTE_MICROSECOND | 返回分钟和毫秒值             |
| MINTUTE_SECOND     | 返回分钟和秒值               |
| HOUR_MICROSECOND   | 返回小时和毫秒值             |
| HOUR_SECOND        | 返回小时和秒值               |
| HOUR_MINUTE        | 返回小时和分钟值             |
| DAY_MICROSECOND    | 返回天和毫秒值               |
| DAY_SECOND         | 返回天和秒值                 |
| DAY_MINUTE         | 返回天和分钟值               |
| DAY_HOUR           | 返回天和小时                 |
| YEAR_MONTH         | 返回年和月                   |



##### 时间和秒转换

| 函数                 | 用法                                                         |
| -------------------- | ------------------------------------------------------------ |
| TIME_TO_SEC(time)    | 将 time 转化为秒并返回结果值。转化的公式为： 小时*3600+分钟 *60+秒 |
| SEC_TO_TIME(seconds) | 将 seconds 描述转化为包含小时、分钟和秒的时间                |

##### 计算日期时间

| 函数                                                         | 用法                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| DATE_ADD(datetime, INTERVAL expr type)， ADDDATE(date,INTERVAL expr type) | 返回与给定日期时间加上expr时间的日期时间                     |
| DATE_SUB(date,INTERVAL expr type)， SUBDATE(date,INTERVAL expr type) | 返回与date减去expr时间的日期                                 |
| DDTIME(time1,time2)                                          | 返回time1加上time2的时间。当time2为一个数字时，代表的是`秒`，可以为负数 |
| SUBTIME(time1,time2)                                         | 返回time1减去time2后的时间。当time2为一个数字时，代表的是`秒`，可以为负数 |
| DATEDIFF(date1,date2)                                        | 返回date1 - date2的日期间隔天数                              |
| TIMEDIFF(time1, time2)                                       | 返回time1 - time2的时间间隔                                  |
| FROM_DAYS(N)                                                 | 返回从0000年1月1日起，N天以后的日期                          |
| TO_DAYS(date)                                                | 返回日期date距离0000年1月1日的天数                           |
| LAST_DAY(date)                                               | 返回date所在月份的最后一天的日期                             |
| MAKEDATE(year,n)                                             | 针对给定年份与所在年份中的天数返回一个日期                   |
| MAKETIME(hour,minute,second)                                 | 将给定的小时、分钟和秒组合成时间并返回                       |
| PERIOD_ADD(time,n)                                           | 返回time加上n后的时间                                        |

`expr`：数字参数

上述函数中`type`的取值与含义：

| type取值       | 含义       |
| -------------- | ---------- |
| HOUR           | 小时       |
| MINUTE         | 分钟       |
| SECOND         | 秒         |
| YEAR           | 年         |
| MONTH          | 月         |
| DAY            | 日         |
| YEAR_MONTH     | 年和月     |
| DAY_HOUR       | 天和小时   |
| DAY_MINUTE     | 天和分钟值 |
| DAY_SECOND     | 天和秒值   |
| HOUR_MINUTE    | 小时和分钟 |
| HOUR_SECOND    | 小时和秒   |
| MINTUTE_SECOND | 分钟和秒   |

##### 日期格式化与解析

| 函数                              | 用法                                       |
| --------------------------------- | ------------------------------------------ |
| DATE_FORMAT(date,fmt)             | 按照字符串fmt格式化日期date值              |
| TIME_FORMAT(time,fmt)             | 按照字符串fmt格式化时间time值              |
| GET_FORMAT(date_type,format_type) | 返回日期字符串的显示格式                   |
| STR_TO_DATE(str, fmt)             | 按照字符串fmt对str进行解析，解析为一个日期 |

上述`非GET_FORMAT`函数中fmt参数常用的格式符：

| 格式符 | 说明                                                         | 格式符  | 说明                                                         |
| ------ | ------------------------------------------------------------ | ------- | ------------------------------------------------------------ |
| %Y     | 4位数字表示年份                                              | %y      | 表示两位数字表示年份                                         |
| %M     | 月名表示月份（January,....）                                 | %m      | 两位数字表示月份 （01,02,03。。。）                          |
| %b     | 缩写的月名（Jan.，Feb.，....）                               | %c      | 数字表示月份（1,2,3,...）                                    |
| %D     | 英文后缀表示月中的天数 （1st,2nd,3rd,...）                   | %d      | 两位数字表示月中的天数(01,02...)                             |
| %e     | 数字形式表示月中的天数 （1,2,3,4,5.....）                    |         |                                                              |
| %H     | 两位数字表示小数，24小时制 （01,02..）                       | %h 和%I | 两位数字表示小时，12小时制 （01,02..）                       |
| %k     | 数字形式的小时，24小时制(1,2,3)                              | %l      | 数字形式表示小时，12小时制 （1,2,3,4....）                   |
| %i     | 两位数字表示分钟（00,01,02）                                 | %S 和%s | 两位数字表示秒(00,01,02...)                                  |
| %W     | 一周中的星期名称（Sunday...）                                | %a      | 一周中的星期缩写（Sun.， Mon.,Tues.，..）                    |
| %w     | 以数字表示周中的天数 (0=Sunday,1=Monday....)                 |         |                                                              |
| %j     | 以3位数字表示年中的天数(001,002...)                          | %U      | 以数字表示年中的第几周， （1,2,3。。）其中Sunday为周中第一 天 |
| %u     | 以数字表示年中的第几周， （1,2,3。。）其中Monday为周中第一 天 |         |                                                              |
| %T     | 24小时制                                                     | %r      | 12小时制                                                     |
| %p     | AM或PM                                                       | %%      | 表示%                                                        |

**GET_FORMAT**函数中`date_type`和`format_type`参数取值如下：

| 日期类型 | 格式化类型 | 返回的格式化字符串 |
| -------- | ---------- | ------------------ |
| DATA     | USA        | %m.%d.%Y           |
| DATA     | JIS        | %Y-%m-%d           |
| DATA     | ISO        | %Y-%m-%d           |
| DATA     | EUR        | %d.%m.%Y           |
| DATA     | INTERNAL   | %Y%m%d             |
| TIME     | USA        | %h:%i:%s %p        |
| TIME     | JIS        | %H:%i:%s           |
| TIME     | ISO        | %H:%i:%s           |
| TIME     | EUR        | %H.%i.%s           |
| TIME     | INTERNAL   | %H%i%s             |
| DATETIME | USA        | %Y-%m-%d %H.%i.%s  |
| DATETIME | JIS        | %Y-%m-%d %H:%i:%s  |
| DATETIME | ISO        | %Y-%m-%d %H:%i:%s  |
| DATETIME | EUR        | %Y-%m-%d %H.%i.%s  |
| DATETIME | INTERNAL   | %Y%m%d%H%i%s       |



#### 流程控制函数

流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。 MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。

| 函数                                                         | 用法                                             |
| ------------------------------------------------------------ | ------------------------------------------------ |
| IF(value,value1,value2)                                      | 如果value的值为TRUE，返回value1， 否则返回value2 |
| IFNULL(value1, value2)                                       | 如果value1不为NULL，返回value1，否则返回value2   |
| CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 .... [ELSE resultn] END | 相当于Java的if...else if...else...               |
| CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 .... [ELSE 值n] END | 相当于Java的switch...case...                     |



#### 加密解密函数

加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。

| 函数                        | 用法                                                         |
| --------------------------- | ------------------------------------------------------------ |
| PASSWORD(str)               | 返回字符串str的加密版本，41位长的字符串。加密结果不可逆 ，常用于用户的密码加密 |
| MD5(str)                    | 返回字符串str的md5加密后的值，也是一种加密方式。若参数为 NULL，则会返回NULL |
| SHA(str)                    | 从原明文密码str计算并返回加密后的密码字符串，当参数为 NULL时，返回NULL。 SHA加密算法比MD5更加安全 。 |
| ENCODE(value,password_seed) | 返回使用password_seed作为加密密码加密value                   |
| DECODE(value,password_seed) | 返回使用password_seed作为加密密码解密value                   |

> PASSWORD在MySQL8.0中`弃用`
> MD5与SHA加密`不可逆`
> ENCODE与DECODE在MySQL8.0中`弃用`

#### MySQL信息函数

MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地 对数据库进行维护工作。

| 函数                                                   | 用法                                                      |
| ------------------------------------------------------ | --------------------------------------------------------- |
| VERSION()                                              | 返回当前MySQL的版本号                                     |
| CONNECTION_ID()                                        | 返回MySQL当前连接的ID                                     |
| DATABASE()，SCHEMA()                                   | 返回MySQL命令行当前所在的数据库                           |
| USER()，CURRENT_USER()、SYSTEM_USER()， SESSION_USER() | 返回当前连接MySQL的用户名，返回结果格式为 “主机名@用户名” |
| CHARSET(value)                                         | 返回字符串value自变量的字符集                             |
| COLLATION(value)                                       | 返回字符串value的比较规则                                 |



#### 其他函数

MySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视 的。

| 函数                           | 用法                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| FORMAT(value,n)                | 返回对数字value进行格式化后的结果数据。n表示`四舍五入`后保留到小数点后n位 |
| CONV(value,from,to)            | 将value的值进行不同进制之间的转换                            |
| INET_ATON(ipvalue)             | 将以点分隔的IP地址转化为一个数字                             |
| INET_NTOA(value)               | 将数字形式的IP地址转化为以点分隔的IP地址                     |
| BENCHMARK(n,expr)              | 将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费 的时间 |
| CONVERT(value USING char_code) | 将value所使用的字符编码修改为char_code                       |

> 以“192.168.1.100”为例，计算方式为192乘以256的3次方，加上168乘以256的2次方，加上1乘以256，再加上100。实际上就是IP的二进制转换为10进制

### <a id="聚合函数">聚合函数</a>

聚合函数作用于一组数据，并对一组数据返回一个值

- **MySQL中聚合函数不能嵌套使用**
- 聚合函数常与[GROUP BY](#数据分组)和[HAVING](#having)一起使用

#### AVG和SUM

可以对**数值型数据**使用**AVG**和**SUM**函数，分别计算平均数与总和

```mysql
SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary)
FROM employees
WHERE job_id LIKE '%REP%';
```

#### MIN和MAX

可以对**任意数据类型**的数据使用**MIN**和**MAX**函数,分别计算最小值与最大值

```MySQL
SELECT MIN(hire_date), MAX(hire_date)
FROM employees;
```

#### COUNT

- **COUNT(*)**返回表中记录总数，适用于**任意数据类型**

  ```MySQL
  SELECT COUNT(*)
  FROM employees
  WHERE department_id = 50;
  ```

- **COUNT(expr)**返回expr不为空的记录总数

  ```MySQL
  SELECT COUNT(commission_pct)
  FROM employees
  WHERE department_id = 50;
  ```

  > 当参数为`数字`时，例如COUNT(1)，意思是把1当作东西，每条数据代表有一个1，记录读完表后有多少个1

> **count(*)，count(1)，count(列名)哪个好?**

- 对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。三者效率相同，都是O(1)
- Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但`好于具体的count(列名)`三。者效率：`COUNT(*) = COUNT(1)> COUNT(字段)`（因为该列如果有null就不记录，可能不是数据总数。可用于看某列有多少个非null值）。

> **能不能使用count(列名)替换count(*)?**

不要使用 count(列名)来替代`count(*)`，`count(*)`是 SQL92 定义的标准统计行数的语法，跟数 据库无关，跟 NULL 和非 NULL 无关。 说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。

## DQL(数据查询语言)

即**SELECT**语句，查询的各种用法，为**DML(数据操作语言)**的一部分，也是主要部分，单独拿出来说明

### 执行顺序

**在SELECT中，除了GROUP BY 和 LIMIT之外，其他位置都可以声明子查询**

```MySQL
#方式1：
SELECT ...,....,...
FROM ...,...,....
WHERE 多表的连接条件
AND 不包含组函数的过滤条件
GROUP BY ...,...
HAVING 包含组函数的过滤条件
ORDER BY ... ASC/DESC
LIMIT ...,...

#方式2：
SELECT ...,....,...
FROM ... JOIN ...
ON 多表的连接条件
JOIN ...
ON ...
WHERE 不包含组函数的过滤条件
AND/OR 不包含组函数的过滤条件
GROUP BY ...,...
HAVING 包含组函数的过滤条件
ORDER BY ... ASC/DESC
LIMIT ...,...

#其中：
#（1）from：从哪些表中筛选
#（2）on：关联多表查询时，去除笛卡尔积
# (LEFT/RIGNT  JOIN)
#（3）where：从表中筛选的条件
#（4）group by：分组依据
#（5）having：在统计结果中再次筛选
#（6）order by：排序
#（7）limit：分页
```

需要记住SELECT查询时的两个顺序：

**1.关键字的顺序是不能颠倒的**

```
SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...
```

**2.SELECT 语句的执行顺序**（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：

```
FROM -> WHERE -> GROUP BY -> HAVING -> SELECT 的字段 -> DISTINCT -> ORDER BY -> LIMIT
```

比如你写了一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的：

```MySQL
SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5
FROM player JOIN team ON player.team_id = team.team_id # 顺序 1
WHERE height > 1.80 # 顺序 2
GROUP BY player.team_id # 顺序 3
HAVING num > 2 # 顺序 4
ORDER BY num DESC # 顺序 6
LIMIT 2 # 顺序 7
```

在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个`虚拟表`，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在SQL的执行过程中，对于我们来说是不可见的

#### SQL的执行原理

SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：

1. 首先先通过`CROSS JOIN求笛卡尔积`，相当于得到虚拟表`vt（virtual table）1-1`；
2. 通过`ON进行筛选`，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表`vt1-2`；
3. `添加外部行`。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表`vt1-3`

当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据

- 当我们拿到了查询数据表的原始数据，也就是最终的虚拟表`vt1(vt1-3/vt1-n)`，就可以在此基础上再进行`WHERE阶段`。在这个阶段中，会根据vt1表的结果进行筛选过滤，得到虚拟表 `vt2`
- 然后进入第三步和第四步，也就是`GROUP和HAVING阶段`。在这个阶段中，实际上是在虚拟表vt2的基础上进行分组和分组过滤，得到中间的虚拟表`vt3`和`vt4`。
- 当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到`SELECT和DISTINCT阶段`
- 首先在`SELECT阶段会提取想要的字段`，然后在`DISTINCT阶段过滤掉重复的行`，分别得到中间的虚拟表`vt5-1`和`vt5-2`
- 当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是`ORDER BY阶段`，得到虚拟表`vt6`
- 最后在 vt6 的基础上，取出指定行的记录，也就是`LIMIT 阶段`，得到最终的结果，对应的是虚拟表`vt7`
- 当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。

同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的 关键字顺序，**所谓底层运行的原理，就是上面的执行顺序**

### 基本查询

#### 一般格式

**一般格式**：

```MySQL
select FIELD1 as "field1", FIELD2 as "field2" from TABLE table where XXXXX ORDER BY FIELDX DESC/ASC
```

- FIELD1，FIELD2：表格的字段名或额外增加的字段的(值或字段名与值)
  除直接写字段名外，还可以写作**TABLE.FIELDx**
- field1，field2：给表格字段起的[别名](#as)。可用一对 `""` 包裹避免与关键字冲突
- TABLE：查询的表格名
- table：给表格起的[别名](#as)
- XXXXX：额外的查询限制条件，过滤数据

> **WHERE**需要声明在**FROM**`后`，**ORDER BY** `前`

**查询结果**：

- `表头`：
  - 默认情况下就是上面的FIELD1，FIELD2；若单纯计算，则为计算式
  - 若不指定别名，则为字段名；若指定别名，则为别名
- `表格`：
  - 计算结果或对应查询结果

**<a id="执行顺序">执行顺序</a>**：

1. **FROM**
1. **WHERE**
2. **SELECT**
3. **ORDER BY**

> **FROM**：获取表，如果有表的连接，则得到连接后的结果，也可以是有别名的查询结果表
>
> **WHERE**：**FROM**得到的数据进一步筛选
>
> **SELECT**：将筛选后的结果选取需要的列
>
> **ORDER BY**：**SELECT**后的结果排序

#### 单独SELECT

最基本的SELECT，没有任何子句，可以拿来计算用

```Mysql
SELECT 1; #没有任何子句
SELECT 9/2; #没有任何子句
```

> 这种单独SELECT的情况实际上是**FROM DUAL**，虚拟表。这个可以省略
>

------

####  * 

一般为`SELECT * FROM XXXXX`

用于`查询`表中`全部字段`。例如：

```MySQL
SELECT *
FROM departments;
```

- 一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符`*`。使用通配符虽然可以节省输入查询语句的时间，但是`获取不需要的列数据通常会降低查询和所使用的应用程序的效率`。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们
- 在生产环境下，`不推荐`直接使用 SELECT * 进行查询

#### ``

必须保证你的字段没有和保留字、数据库系统或常见方法冲突

如果坚持使用，在SQL语句中使用 `` 引起来

也可以所有字段、表名都用``引起来（navicat默认如此）

```MySQL
SELECT * FROM `order`;
```



#### DISTINCT

**DISTINCT**(不同的)：用于查询字段下`数据的所有种类`，或`去除重复行`

- **DISTINCT**需要`放到所有列名的前面`，如果写成`SELECT AAA, DISTINCT BBB FROM employees`会报错
- **DISTINCT**其实是对后面所有列名的组合进行`去重`，如果写成`SELECT DISTINCT AAA, BBB FROM TABLE`，结果为AAA和BBB哪个不一样的多，以哪个为准

```mysql
SELECT DISTINCT department_id
FROM employees;
```



#### <a id="as">别名</a>

- 重命名一个`列`(`SELECT中`)
- 重命名一个`表`(`FROM中`)
- 便于计算
- 紧跟列名，也可以在`列名和别名之间加入关键字`**AS**，别名使用**双引号**，以便在别名中包含空格或特殊的字符并区分大小写
- **AS** `可以省略`
- 建议别名简短，见名知意

```MySQL
SELECT last_name "Name", salary*12 "Annual Salary"
FROM employees;
```

> - `列`的别名`只能`在**ORDER BY**中使用，`不能`在**WHERE**中使用
>   因为SQL语句的`执行顺序先FROM WHERE，再SELECT,最后ORDER BY`
>
> - `表`的别名可以在哪里都能使用，**一旦定义表的别名，就只能使用表的别名，不能使用原名**。一般使用于[多表查询](#多表查询)



#### 查询常数

即在SELECT查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的

```MySQL
SELECT '常数' as corporation, last_name FROM employees;
```



#### 空值

- 所有运算符或列值遇到null值，运算的结果都为null
- 在MySQL 里面，空值不等于空字符串。一个空字符串的长度是0，而一个空值的长度是空。而且，在MySQL里面，空值是占用空间的

```mysql
SELECT employee_id,salary,commission_pct,
12 * salary * (1 + commission_pct) "annual_sal"
FROM employees;
# 因为commission_pct里面是null的字段,最后结果也为null
```

### 结果排序

`默认情况`下，查询结果根据数据`添加顺序`排序

此外，可以使用**ORDER BY**子句进行排序：

- **ASC**(ascend)：`升序`
- **DESC**(descend)：`降序`

> **ORDER BY**`默认`情况下按`升序`排序(从小到大)

#### 单列排序

- 格式：

  **SELECT** `field1`,`field2`
  **FROM** `table1`
  **ORDER BY** `fieldx` **DESC/ASC**;

  > fieldx可以是field1，field2，也可以是其他field

- 示例：

  ```mysql 
  SELECT last_name, job_id, department_id, hire_date
  FROM employees
  ORDER BY hire_date DESC ;
  ```

#### 多列排序

- 格式：

  **SELECT** `field1`,`field2`
  **FROM** `table1`
  **ORDER BY** `fieldx` **DESC**/**ASC**,`fieldy` **DESC**/**ASC**,...;

  > - 排序优先性从前往后
  > - 在对多列进行排序的时候，首先排序的`第一列`必须`有相同的列值`，`才会对第二列进行排序`。如果第 一列数据中所有值都是唯一的，将不再对第二列进行排序

- 示例：

  ```mysql 
  SELECT last_name, department_id, salary
  FROM employees
  ORDER BY department_id, salary DESC;
  ```

### 结果分页

所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件

MySQL中使用**LIMIT**实现分页

- 格式：

  **LIMIT** [`位置偏移量`,]`行数`;

  > `偏移量`：从哪一行开始显示，是一个`可选参数`，如果不指定偏移量，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是 1，以此类推）
  >
  > `行数`：指示返回的记录条数
  >
  > **注意：LIMIT 子句必须放在整个SELECT语句的最后**

- 分页显示：**（当前页数-1）*每页条数，每页条数**

  ```MySQL
  SELECT * FROM table
  LIMIT(PageNo - 1)*PageSize,PageSize;
  ```

- 好处：

  约束返回结果的数量可以`减少数据表的网络传输量`，也可以`提升查询效率`。如果我们知道返回结果只有1条，就可以使用LIMIT 1 ，告诉SELECT语句只需要返回一条记录即可。这样的好处就是SELECT不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回

- 示例：

  ```MySQL
  --前10条记录：
  SELECT * FROM 表名 LIMIT 0,10;
  或者
  SELECT * FROM 表名 LIMIT 10;
  --第11至20条记录：
  SELECT * FROM 表名 LIMIT 10,10;
  --第21至30条记录：
  SELECT * FROM 表名 LIMIT 20,10;
  ```

#### OFFSET

MySQL8.0新特性：**LIMIT** ... **OFFSET** ...

- **OFFSET**：就是偏移量，**LIMIT**的第一个可选参数
- 该语句意思就是`LIMIT 数据条数 OFFSET 偏移量`

### <a id="union">结果合并</a>

使用**UNION**关键字

- **作用**：`合并查询结果`。利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的`列数和数据类型必须相同`，并且`相互对应`。各个SELECT语句之间使用**UNION**或**UNION ALL**关键字分隔

- **格式**

  ```MySQL
  SELECT column,... FROM table1
  UNION [ALL]
  SELECT column,... FROM table2
  ```

#### UNION

**UNION**操作符返回两个查询的结果集 的并集，`去除重复记录`：

![](https://cdn.jsdelivr.net/gh/6hqt9/TyporaNotes/img/union.png)

```mysql
SELECT * FROM employees WHERE email LIKE '%a%'
UNION
SELECT * FROM employees WHERE department_id>90;
```

#### UNION ALL

**UNION ALL**操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，`不去重`

![](https://cdn.jsdelivr.net/gh/6hqt9/TyporaNotes/img/unionall.png)

```mysql
SELECT id,cname FROM t_chinamale WHERE csex='男'
UNION ALL
SELECT id,tname FROM t_usmale WHERE tGender='male';

```

> 执行**UNION ALL**语句时所需要的资源比**UNION**语句`少`。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则`尽量使用UNION ALL语句`，以`提高数据查询的效率`

### <a id="数据分组">数据分组</a>

常与[聚合函数](#聚合函数)一起使用

#### 单列分组

使用**GROUP BY**子句`将表中的数据分成若干组`

- 格式如下：
  **SELECT** column, group_function(column)
  **FROM** table
  [**WHERE** condition]
  [**GROUP BY** group_by_expression]
  [**ORDER BY** column];

> `WHERE一定放在FROM后面`

- 在**SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中**
  反之，**GROUP BY中声明的字段可以不出现在SELECT中**
- GROUP BY声明在FROM后面、WHERE后面，ORDER BY 前面、LIMIT前面
- 示例：

```MySQL
SELECT department_id,AVG(salary),SUM(salary)
FROM employees
GROUP BY department_id
```

#### 多列分组

- 即GROUP BY多个字段
- 示例：

```MySQL
#两个方式查询结果数量与内容相同，只是列不一样，本质上都是两列内容的排列组合
#方式1：
SELECT department_id,job_id,AVG(salary)
FROM employees
GROUP BY department_id,job_id;
#方式2：
SELECT job_id,department_id,AVG(salary)
FROM employees
GROUP BY job_id,department_id;
```

#### WITH ROLLUP

- **作用**：使用**WITH ROLLUP**关键字之后，在所有查询出的分组记录之后`增加一条记录`，该记录对查询出的所有记录进行计算
- **示例**：

```mysql
SELECT department_id,AVG(salary)
FROM employees
GROUP BY department_id WITH ROLLUP;
#这里增加一条记录，结果是所有记录salary的平均值
```

> - 在**MySQL5.7**中，**使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序**，会报错。即ROLLUP和ORDER BY是互相排斥的
> - 在**MySQL8.0**中，不会报错，但建议不同时使用

#### <a id="having">HAVING</a>

常与[聚合函数](#聚合函数)一起使用

 在**WHERE**子句中**不能使用聚合函数**，否则会报错。此时可以使用**HAVING**子句用来过滤数据。

- 当过滤条件中有聚合函数时，则此过滤条件必须声明在HAVING中。
- 当过滤条件中没有聚合函数时，则此过滤条件声明在WHERE中或HAVING中都可以。但是建议声明在WHERE中

##### 基本使用

- 格式

  **SELECT** column, group_function(column)
  **FROM** table
  [**WHERE** condition]
  [**GROUP BY** group_by_expression]
  [**HAVING** group_condition]
  [**ORDER BY** column];

- 示例：

```MySQL
SELECT department_id, MAX(salary)
FROM employees
GROUP BY department_id
HAVING MAX(salary)>10000 ;
```

- 注意事项
  - **HAVING**必须声明在**GROUP BY**的**后面**
  - 满足**HAVING**子句中条件的分组将被显示
  - 开发中，我们使用HAVING的**前提是SQL中使用了GROUP BY**
  - **HAVING**中使用别名的版本为5.75之后，之前不可使用



##### HAVING vs WHERE

**区别1：WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING必须要与GROUP BY配合使用，可以把分组计算的函数和分组字段作为筛选条件。**

这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为， 在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING在 GROUP BY之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是WHERE无法完成的。另外，WHERE排除的记录不再包括在分组中。

**区别2：如果需要通过连接从关联表中获取需要的数据，WHERE是先筛选后连接，而 HAVING 是先连接后筛选。**

这一点，就决定了`在关联查询中，WHERE比HAVING更高效`。因为WHERE可以先筛选，用一 个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。

小结如下：

| 关键字 | 用法                         | 缺点                                   |
| ------ | ---------------------------- | -------------------------------------- |
| WHERE  | 先筛选数据再关联，执行效率高 | 不能使用分组中的计算函数进行筛选       |
| HAVING | 可以使用分组中的计算函数     | 在最后的结果集中进行筛选，执行效率较低 |

**开发中的选择：**

WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组 统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发 挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别





### <a id="多表查询">多表查询</a>

#### 注意事项

##### 笛卡尔积

如果多表查询格式错误，会出现笛卡尔积的结果。即不同表的每条数据排列组合作为结果

SQL92中，笛卡尔积也称为`交叉连接`，英文是**CROSS JOIN**。在 SQL99 中也是使用 **CROSS JOIN**表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关

笛卡尔积的错误会在下面条件下产生：

1. 省略多个表的连接条件（或关联条件）
2. 连接条件（或关联条件）无效
3. 所有表中的所有行互相连接

##### 同名列名

- **多个表中有相同列时，必须在列名之前加上表名前缀**
- 在不同表中具有相同列名的列可以用`表名`加以区分

```mysql 
SELECT employees.last_name, departments.department_name,employees.department_id
FROM employees, departments
WHERE employees.department_id = departments.department_id;
```

##### 表的别名

- 使用别名可以`简化查询`
- `列名前使用表名前缀`可以`提高查询效率`

```MySQL
SELECT e.employee_id, e.last_name, e.department_id,
d.department_id, d.location_id
FROM employees e , departments d
WHERE e.department_id = d.department_id;
```

> `阿里开发规范` ：
>
> 【 `强制` 】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。
>
> `说明`：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常
>
> `正例`：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id;
>
> `反例`：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年 后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常：Column 'name' in field list is ambiguous。

##### 多表连接条件

**连接 n个表,至少需要n-1个连接条件**

比如，连接三个表，至少需要两个连接条件



#### 连接分类

##### 等值与非等值连接

连接的一种分类

即连接的限定条件是`=`还是其他



##### 自连接与非自连接

**自连接**，即参与连接的`两张表其实是同一张表`，只是用`取别名`的方式`虚拟成两张表`以代表不同的意义。然后两个表再进行内连接，外连接等查询。不同表联合查询就是**非自连接**

```mysql
# 查询员工id,员工姓名及其管理者的id和姓名
SELECT emp.employee_id,emp.last_name,mgr.employee_id,mgr.last_name
FROM employees emp ,employees mgr
WHERE emp.`manager_id` = mgr.`employee_id`;
```



##### 内连接

两个表联合查询后的结果集**只为满足查询条件的结果**

###### SQL92

```mysql 
SELECT employee_id,department_name
FROM employees e,departments d
WHERE e.`department_id` = d.department_id;
```

###### SQL99

**SELECT** FIELD1 field1,FIELD2 field2,...
**FROM** TABLE1 table1 **INNER JOIN** TABLE2 table2
**ON** 连接条件
**WHERE** 其他过滤条件

> - **INNER**可以省略
> - 关键字 **JOIN**、**INNER JOIN**、**CROSS JOIN** 的含义是一样的，都表示**内连接**

```mysql
SELECT last_name,department_name
FROM employees e INNER JOIN departments d
ON e.`department_id` = d.`department_id`;
```



##### 外连接

两个表在连接过程中**除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的 行** ，这种连接称为左（或右）外连接。**没有匹配的行时, 结果表中相应的列为空(NULL)**

- 如果是**左外连接**，则连接条件中`左边`的表也称为`主表` ，右边的表称为`从表 `
- 如果是**右外连接**，则连接条件中`右边`的表也称为`主表` ，左边的表称为`从表` 

###### SQL92

- Oracle对SQL92支持较好，而**MySQL则不支持SQL92的外连接**
- 在 SQL92 中采用**(+)**代表**从表**所在的位置。即左或右外连接中，**(+)**表示哪个是**从表**
- 而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接

Oracle示例：

```MySQL
#左外连接
SELECT last_name,department_name
FROM employees ,departments
WHERE employees.department_id = departments.department_id(+);
#右外连接
SELECT last_name,department_name
FROM employees ,departments
WHERE employees.department_id(+) = departments.department_id;
```



###### SQL99

- 左外连接：左边表全部都有

  **SELECT** FIELD1 field1,FIELD2 field2,...
  **FROM** TABLE1 table1 **LEFT OUTER JOIN** TABLE2 table2
  **ON** 连接条件
  **WHERE** 其他过滤条件

- 右外连接：右边表全部都有

  **SELECT** FIELD1 field1,FIELD2 field2,...
  **FROM** TABLE1 table1 **RIGHT OUTER JOIN** TABLE2 table2
  **ON** 连接条件
  **WHERE** 其他过滤条件

- 满外连接(`MySQL不支持`)

  **SELECT** FIELD1 field1,FIELD2 field2,...
  **FROM** TABLE1 table1 **FULL OUTER JOIN** TABLE2 table2
  **ON** 连接条件
  **WHERE** 其他过滤条件

> - **OUTER**可以省略
> - MySQL`不支持`**FULL JOIN**，但是可以用 **LEFT JOIN [UNION](#union) RIGHT JOIN**代替





#### 七种JOIN

![](https://cdn.jsdelivr.net/gh/6hqt9/TyporaNotes/img/7join.png)

##### 说明

**左**：左边的一小块

**中**：中间的一小块

**右**：右边的一小块

**左外连接**：左边表数据全部有，右边对不上的补**NULL**

**右外连接**：右边表数据全部有，左边对不上的补**NULL**

**左**/**右**：通过[WHERE](#执行顺序)，在**左/右外连接**的基础上，**筛选出右/左边补了NULL的数据**



##### 中

- 格式

  **SELECT** FIELD1 field1,FIELD2 field2,...
  **FROM** TABLE1 table1 **INNER JOIN** TABLE2 table2
  **ON** 连接条件
  **WHERE** 其他过滤条件

- 示例

  ```MySQL
  # 中图：内连接
  SELECT employee_id,department_name
  FROM employees e JOIN departments d
  ON e.`department_id` = d.`department_id`;
  ```

##### 左中

- 格式

  **SELECT** FIELD1 field1,FIELD2 field2,...
  **FROM** TABLE1 table1 **LEFT OUTER JOIN** TABLE2 table2
  **ON** 连接条件
  **WHERE** 其他过滤条件

- 示例

  ```MySQL
  # 左上图：左外连接
  SELECT employee_id,department_name
  FROM employees e LEFT JOIN departments d
  ON e.`department_id` = d.`department_id`;
  ```

##### 中右

- 格式

  **SELECT** FIELD1 field1,FIELD2 field2,...
  **FROM** TABLE1 table1 **LEFT OUTER JOIN** TABLE2 table2
  **ON** 连接条件
  **WHERE** 其他过滤条件

- 示例

  ```MySQL
  # 右上图：右外连接
  SELECT employee_id,department_name
  FROM employees e RIGHT JOIN departments d
  ON e.`department_id` = d.`department_id`;
  ```

##### 左

- 格式

  **SELECT** FIELD1 field1,FIELD2 field2,...
  **FROM** TABLE1 table1 **LEFT OUTER JOIN** TABLE2 table2
  **ON** 连接条件
  **WHERE** table2.fieldx IS NULL

- 示例

  ```MySQL
  # 左中图：
  SELECT employee_id,department_name
  FROM employees e LEFT JOIN departments d
  ON e.`department_id` = d.`department_id`
  WHERE d.`department_id` IS NULL;
  ```

##### 右

- 格式

  **SELECT** FIELD1 field1,FIELD2 field2,...
  **FROM** TABLE1 table1 **LEFT OUTER JOIN** TABLE2 table2
  **ON** 连接条件
  **WHERE** table1.fieldx IS NULL

- 示例

  ```MySQL
  # 右中图：
  SELECT employee_id,department_name
  FROM employees e RIGHT JOIN departments d
  ON e.`department_id` = d.`department_id`
  WHERE e.`department_id` IS NULL;
  ```

##### 左右

- 格式

  **SELECT** FIELD1 field1,FIELD2 field2,...
  **FROM** TABLE1 table1 **LEFT OUTER JOIN** TABLE2 table2
  **ON** 连接条件
  **WHERE** table1.fieldx IS NULL
  **UNION ALL**
  **SELECT** FIELD1 field1,FIELD2 field2,...
  **FROM** TABLE1 table1 **LEFT OUTER JOIN** TABLE2 table2
  **ON** 连接条件
  **WHERE** table2.fieldx IS NULL

- 示例

  ```MySQL
  # 右下图：左 UNION ALL 右
  SELECT employee_id,department_name
  FROM employees e LEFT JOIN departments d
  ON e.`department_id` = d.`department_id`
  WHERE d.`department_id` IS NULL
  UNION ALL
  SELECT employee_id,department_name
  FROM employees e RIGHT JOIN departments d
  ON e.`department_id` = d.`department_id`
  WHERE e.`department_id` IS NULL;
  ```

##### 左中右

- 格式

  **SELECT** FIELD1 field1,FIELD2 field2,...
  **FROM** TABLE1 table1 **LEFT OUTER JOIN** TABLE2 table2
  **ON** 连接条件
  **WHERE** table1.fieldx IS NULL
  **UNION ALL**
  **SELECT** FIELD1 field1,FIELD2 field2,...
  **FROM** TABLE1 table1 **LEFT OUTER JOIN** TABLE2 table2
  **ON** 连接条件
  **WHERE** 其他过滤条件

- 示例

  ```MySQL
  # 左下图：满外连接
  # 方式1：左中 UNION ALL 右
  SELECT employee_id,department_name
  FROM employees e LEFT JOIN departments d
  ON e.`department_id` = d.`department_id`
  UNION ALL
  SELECT employee_id,department_name
  FROM employees e RIGHT JOIN departments d
  ON e.`department_id` = d.`department_id`
  WHERE e.`department_id` IS NULL;
  
  
  # 方式2：左 UNION ALL 中右
  SELECT employee_id,department_name
  FROM employees e LEFT JOIN departments d
  ON e.`department_id` = d.`department_id`
  WHERE d.`department_id` IS NULL
  UNION ALL
  SELECT employee_id,department_name
  FROM employees e RIGHT JOIN departments d
  ON e.`department_id` = d.`department_id`;
  ```



#### NATURAL

**SELECT** FIELD1 field1,FIELD2 field2,...
**FROM** TABLE1 table1 **NATURAL JOIN** TABLE2 table2
**WHERE** XXXXX

SQL99在SQL92的基础上提供了一些特殊语法，比如**NATURAL JOIN**用来表示**自然连接**。可以把自然连接理解为SQL92中的等值连接。它会帮你`自动查询两张连接表中所有相同的字段` ，然后`进行等值连接` 

在SQL92标准中：

```mysql
SELECT employee_id,last_name,department_name
FROM employees e JOIN departments d
ON e.`department_id` = d.`department_id`
AND e.`manager_id` = d.`manager_id`;
```

在 SQL99 中可以写成：

```mysql
SELECT employee_id,last_name,department_name
FROM employees e NATURAL JOIN departments d;
```

#### USING

**SELECT** FIELD1 field1,FIELD2 field2,...
**FROM** TABLE1 table1 **JOIN** TABLE2 table2
**USING** (FIELDx)
**WHERE** table1.fieldx IS NULL

SQL99还支持使用 USING 指定数据表里的`同名字段`进行等值连接。但是只能配合JOIN一起使用。比如：

```mysql
SELECT employee_id,last_name,department_name
FROM employees e JOIN departments d
USING (department_id);
```

USING 指定了具体的相同的字段名称，你需要在 USING 的括号 () 中填入要指定的同名字段。同时使用 JOIN...USING 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的：

```mysql
SELECT employee_id,last_name,department_name
FROM employees e ,departments d
WHERE e.department_id = d.department_id;
```

### 子查询

也叫内查询，即SELECT的嵌套使用

**在SELECT中，除了GROUP BY 和 LIMIT之外，其他位置都可以声明子查询**

子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入

SQL 中子查询的使用大大增强了SELECT查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较

#### 格式

**SELECT** select_list
**FROM** table
**WHERE** expr operator
									**(SELECT** select_list
									 FROM table**)**;

- 子查询（内查询）在`主查询之前`一次`执行`完成
- 子查询的`结果被主查询（外查询）使用 `
- **注意事项**
  - 子查询要包含在括号内
  - 将子查询放在比较条件的右侧
  - 单行操作符对应单行子查询，多行操作符对应多行子查询

#### 分类

**分类方式1：**

我们按内查询的结果返回一条还是多条记录，将子查询分为单行子查询 、多行子查询 。

- `单行子查询`

  子查询的查询结果返回一条记录(如一个确定的值)

- `多行子查询`

  子查询的查询结果返回多条记录

**分类方式2：**

我们按内查询是否被执行多次，将子查询划分为`相关(或关联)子查询`和`不相关(或非关联)子查询`

子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。

同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询

#### 单行子查询

**子查询结果是一个单个确定的值，这个查询结果可以用来`比较`**

##### 单行比较操作符

| 操作符 | 含义                     |
| ------ | ------------------------ |
| =      | equal to                 |
| >      | greater than             |
| >=     | greater than or equal to |
| <      | less than                |
| <=     | less than or equal to    |
| <>     | not equal to             |

##### 代码示例

**题目：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资**

```MySQL
SELECT last_name, job_id, salary
FROM eployees
WHERE job_id = (
                SELECT job_id
                FROM eployees
                WHERE employee_id = 141
)
AND   salary > (
                SELECT salary
                FROM eployees
                WHERE employee_id = 143);
```

**题目：查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id，manager_id，department_id**

```MySQL
# 实现方式一：不成对比较
SELECT employee_id, manager_id, department_id
FROM employees
WHERE manager_id IN
                (SELECT manager_id
                 FROM employees
                 WHERE employee_id IN (174,141))
AND department_id IN
                (SELECT department_id
                 FROM employees
                 WHERE employee_id IN (174,141))
AND employee_id NOT IN(174,141);

# 实现方式二：成对比较
SELECT employee_id, manager_id, department_id
FROM employees
WHERE (manager_id, department_id) IN
                (SELECT manager_id, department_id
                 FROM employees
                 WHERE employee_id IN (141,174))
AND employee_id NOT IN (141,174);
```

##### HAVING中子查询

- 首先执行子查询
- 向主查询中的HAVING子句返回结果

**题目：查询最低工资大于50号部门最低工资的部门id和其最低工资**

```MySQL
SELECT department_id, MIN(salary)
FROM employees
GROUP BY department_id
HAVING MIN(salary) >
            (SELECT MIN(salary)
             FROM employees
             WHERE department_id = 50);
```

##### CASE中子查询

在CASE表达式中使用单列子查询：

**题目：显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800 的department_id相同，则location为’Canada’，其余则为’USA’**

```MySQL
SELECT employee_id, last_name,
    (CASE department_id
     WHEN (SELECT department_id FROM departments
           WHERE location_id = 1800)THEN 'Canada'
     ELSE 'USA' END) location
FROM employees;
```

##### 空值问题

```MySQL
SELECT last_name, job_id
FROM employees
WHERE job_id =
                (SELECT job_id
                 FROM employees
                 WHERE last_name = 'Haas');
```

> 子查询不返回任何行

##### 非法使用子查询

```MySQL
SELECT employee_id, last_name
FROM employees
WHERE salary =
(SELECT MIN(salary)
FROM employees
GROUP BY department_id);
```

> 多行子查询使用单行比较符

#### 多行子查询

**子查询结果是多个值，可以将查询结果可以用来`比较`**

- 也称为集合比较子查询
- 内查询返回多行
- 使用多行比较操作符

##### 多行比较操作符

| 操作符 | 含义                                                     |
| ------ | -------------------------------------------------------- |
| IN     | 等于列表中的任意一个                                     |
| ANY    | 需要和单行比较操作符一起使用，和子查询返回的某一个值比较 |
| ALL    | 需要和单行比较操作符一起使用，和子查询返回的所有值比较   |
| SOME   | 实际上是ANY的别名，作用相同，一般常使用ANY               |

> ANY，ALL需要搭配单行比较符使用。同时都可以搭配运算符使用(如NOT)

##### 代码示例

**题目：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary**

```MySQL
SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE job_id <> 'IT_PROG' 
AND salary < ANY
                (SELECT salary
                 FROM emplyees
                 WHERE job_id = 'IT_PROG');
```

**题目：查询平均工资最低的部门id**

```MySQL
#方式1：
SELECT department_id
FROM employees
GROUP BY department_id
HAVING AVG(salary) = (
        SELECT MIN(avg_sal)
        FROM (
            SELECT AVG(salary) avg_sal
            FROM employees
            GROUP BY department_id
            ) dept_avg_sal
);

#方式2：
SELECT department_id
FROM employees
GROUP BY department_id
HAVING AVG(salary) <= ALL (
                        SELECT AVG(salary) avg_sal
                        FROM employees
                        GROUP BY department_id
);
```

##### 空值问题

```MySQL
SELECT last_name
FROM employees
WHERE employee_id NOT IN (
                SELECT manager_id
                FROM employees
                );
#                WHERE manager_id IS NOT NULL);
```

> NOT IN 进行的是不等于(`!=`/`<>`)运算，相当于eid != mid1 AND eid != mid2 ......
> 因此只要查询结果中有null值，最后就查不到结果

#### 相关子查询

**相关子查询按照一行接一行的顺序执行，主查询的每一条数据的查询都会执行一次子查询**

如果子查询的执行依赖于外部查询，通常情况下都是因为**子查询中的表用到了外部的表**，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为**关联子查询** 

1. 从主查询中获取候选列
2. 子查询使用主查询的数据
3. 如果满足子查询的条件则返回该行

1. ......

> 说明：**子查询中使用主查询中的列**

##### FROM中子查询

**FROM**：选择查询的表。**FROM中子查询**即将子查询结果作为查询的表，在这个表中进行查询

- 子查询是作为from的一部分
- `子查询结果表`需要`取别名`
- 把子查询结果表当成一张“临时的虚拟的表”来使用

**题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id**

```MySQL
# 方式一：使用相关子查询
SELECT last_name, salary, department
FROM employees e1
WHERE salary > 
             (SELECT AVG(salary)
    	      FROM employees e2
    	      WHERE department_id = e1.`department_id`);
    	      
# 方式二：在FROM中声明子查询
SELECT e.last_name, e.salary, e.department_id
FROM employees e, (
    			SELECT department_id, AVG(salary) avg_sal
    			FROM employees
    			GROUP BY department_id) t_dept_avg_salary
WHERE e.department_id = t_dept_avg_salary.department_id
AND e.salary > t_dept_avg_salary.avg_sal;
```

##### ORDER BY中子查询

**题目：查询员工的id,salary,按照department_name排序**

```MySQL
SELECT employee_id, salary
FROM employees e
ORDER BY (
         SELECT department_name
         FROM departments d
         WHERE e.`department_id` = d.`department_id`)
ASC;
```

**题目：若employees表中employee_id与job_history表中employee_id相同的数目不小于2，输出这些相同 id的员工的employee_id,last_name和其job_id**

```MySQL
SELECT e.employee_id, last_name,e.job_id
FROM employees e
WHERE 2 <= (SELECT COUNT(*)
        FROM job_history
        WHERE employee_id = e.employee_id
);
```

##### EXISTS与NOT EXISTS

- 相关子查询通常也会和**EXISTS**操作符一起来使用，用来检查在**子查询中是否存在满足条件的行**
- **如果在子查询中`不存在`满足条件的行：**
  - 条件返回FALSE
  - 继续在子查询中查找
- **如果在子查询中`存在`满足条件的行：**
  - 不在子查询中继续查找
  - 条件返回 TRUE
- **NOT EXISTS**关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。

**题目：查询公司管理者的employee_id，last_name，job_id，department_id信息**

```MySQL
# 方式一：EXISTS
SELECT employee_id, last_name, job_id, department_id
FROM employees e1
WHERE EXISTS ( SELECT *
        FROM employees e2
        WHERE e2.manager_id =
        e1.employee_id);

# 方式二：自连接
SELECT DISTINCT e1.employee_id, e1.last_name, e1.job_id, e1.department_id
FROM employees e1 JOIN employees e2
ON e1.employee_id = e2.manager_id;

# 方式三：IN
SELECT employee_id, last_name, job_id, department_id
WHERE employee_id IN (
        SELECT DISTINCT manager_id
        FROM employees);
```

**题目：查询departments表中，不存在于employees表中的部门的department_id和department_name**

```MySQL
# 方式一：
SELECT d.department_id, d.department_name
FROM departments e RIGHT JOIN departments d
ON e.`department_id` = d.`department_id`
WHERE e.`department_id` IS NULL;

# 方式二：
SELECT department_id, department_name
FROM departments d
WHERE NOT EXISTS (
            SELECT *
            FROM employees e
            WHERE d.`department_id` = e.`department_id`);
```

> 这里的SELECT，*可以是任意字段、值。只需要看有没有结果

##### 相关更新

```MySQL
UPDATE table1 alias1
SET column = (SELECT expression
FROM table2 alias2
WHERE alias1.column = alias2.column);
```

使用相关子查询依据一个表中的数据更新另一个表的数据。

**题目：在employees中增加一个department_name字段，数据为员工对应的部门名称**

```MySQL
# 1）
ALTER TABLE employees
ADD(department_name VARCHAR2(14));

# 2）
UPDATE employees e
SET department_name = (SELECT department_name
FROM departments d
WHERE e.department_id = d.department_id);
```

##### 相关删除

```MySQL
DELETE FROM table1 alias1
WHERE column operator (SELECT expression
FROM table2 alias2
WHERE alias1.column = alias2.column);
```

使用相关子查询依据一个表中的数据删除另一个表的数据。

**题目：删除表employees中，其与emp_history表皆有的数据**

```MySQL
DELETE FROM employees e
WHERE employee_id in(
    SELECT employee_id
    FROM emp_history
    WHERE employee_id = e.employee_id
);
```

## DML(数据操作语言)  

**Data Manipulation Language 数据操作语言**

- DML操作默认情况下，执行完以后都会自动提交数据
- 如果需要回滚数据，需要保证在DML前，进行设置：**SET AUTOCOMMIT = FALSE;**

### 插入数据

#### INSERT插入

- 使用这种语法**一次**只能向表中插入**一条数据**
- **VALUES**也可以写成**VALUE**，但是**VALUES是标准写法**
- 字符和日期型数据应包含在单引号中

##### 默认顺序插入

- 格式：

```mysql
INSERT INTO 表名
VALUES (value1,value2,....);
```

- 示例：

```mysql
INSERT INTO departments
VALUES (70, 'Pub', 100, 1700);

INSERT INTO departments
VALUES (100, 'Finance', NULL, NULL);
```

> 值列表中需要为表的`每一个字段`指定值，并且值的顺序必须和数据表中字段定义时的`顺序相同`

##### 指定字段插入

- 格式：

```mysql
INSERT INTO 表名(column1 [, column2, …, columnn])
VALUES (value1 [,value2, …, valuen]);
```

- 示例：

```MySQL
INSERT INTO emp1(id,hire_date,salary,`name`)
VALUES(2,'1999-09-09',4000,'Jerry');
# 说明：没有进行赋值的hire_date 的值为 null
INSERT INTO emp1(id,salary,`name`)
VALUES(3,4500,'shk')
```

> 为表的指定字段插入数据，就是在INSERT语句中只向`部分字段中插入值`，而`其他字段`的值为表定义时的`默认值`
>
> 在 INSERT子句中`随意列出列名`，但是一旦列出，VALUES中要插入的`value1,....valuen`需要与`column1,...columnn`列`一一对应`。如果类型不同，将无法插入，并且MySQL会产生错误

##### 同时插入多条

- 格式：

```mysql
INSERT INTO table_name
VALUES
(value1 [,value2, …, valuen]),
(value1 [,value2, …, valuen]),
……
(value1 [,value2, …, valuen]);
# 或者
INSERT INTO table_name(column1 [, column2, …, columnn])
VALUES
(value1 [,value2, …, valuen]),
(value1 [,value2, …, valuen]),
……
(value1 [,value2, …, valuen]);
```

- 示例：

```MySQL
INSERT INTO emp1(id,NAME,salary)
VALUES
(4,'Jim',5000),
(5,'张俊杰',5500);
```

> 一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句在处理过程中`效率更高`。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句`快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入

> 使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息，这些信息的含义如下：
>
> - `Records`：表明插入的记录条数
> - `Duplicates`：表明插入时被忽略的记录，原因可能是这些记录包含了重复的主键值
> - `Warnings`：表明有问题的数据值，例如发生数据类型转换

#### 查询结果插入

- 格式：

  ```mysql
  INSERT INTO 目标表名
  (tar_column1 [, tar_column2, …, tar_columnn])
  SELECT(src_column1 [, src_column2, …, src_columnn])
  FROM 源表名
  [WHERE condition]
  ```

  - 在INSERT语句中加入子查询
  - **不必书写VALUES子句**
  - 子查询中的`值列表`应与INSERT子句中的`列名`**一一对应**

- 示例：

```mysql
INSERT INTO emp1(id,NAME,salary,hire_date)
# 查询语句
SELECT employee_id,last_name,salary,hire_date
# 查询的字段一定要与添加到的表的字段一一对应
FROM employees
WHERE department_id IN (70,60);
```

> - `插入表`中要添加数据的**字段的长度不能低于**`查询表`中查询的字段的长度。
> - `插入表`中要添加数据的字段的长度低于`查询表`中查询的字段的长度的话，就有添加不成功的风险

### 更新数据

- 格式：

  ```mysql
  UPDATE table_name
  SET column1=value1, column2=value2, ..., column=valuen
  [WHERE condition]
  ```

  - 可以一次更新**多条**数据。
  - 使用**WHERE**子句指定需要更新的数据
  - 如果**省略WHERE**子句，则表中的**所有数据都将被更新**

- 示例：

```mysql
UPDATE employees
SET department_id = 70
WHERE employee_id = 113;

UPDATE copy_emp
SET department_id = 110;
```

- 错误：
  - 语法错误
  - 约束影响(外键)

```mysql
UPDATE employees
SET department_id = 55
WHERE department_id = 110;
#不存在55号部门
```

### 删除数据

- 格式

  ```MySQL
  DELETE FROM table_name [WHERE <condition>];
  ```

  - `table_name`指定要执行删除操作的表；`[WHERE ]`为可选参数，指定删除条件
  - **如果省略WHERE子句，则表中的全部数据将被删除**

- 示例

  ```mysql
  DELETE FROM departments
  WHERE department_name = 'Finance';
  
  DELETE FROM copy_emp;
  ```

- 错误

  - 语法错误
  - 约束影响(外键)

  ```MySQL
  DELETE FROM departments
  WHERE department_id = 60;
  ```

  

## DDL(数据定义语言)

 **Data Definition Languages 数据定义语言**

### 命名规则

- **数据库名**、**表名**`不得超过30个字符`，`变量名限制为29个`
- 必须只能包含`A–Z,` `a–z`, `0–9`, `_`共63个字符
- 数据库名、表名、字段名等对象名中间`不要包含空格`
- 同一个MySQL软件中，`数据库不能同名`；同一个库中，`表不能重名`；同一个表中，`字段不能重名`
- 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用`（着重号）引起来
- 保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，例如数据类型在一个表里是整数，那在另一个表里也为整数

> **阿里巴巴《Java开发手册》之MySQL字段命名**
>
> - 【`强制`】表名、字段名必须使用**小写字母或数字**，**禁止出现数字开头**，**禁止两个下划线中间只出现数字**。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑
>   - 正例：aliyun_admin，rdc_config，level3_name
>   - 反例：AliyunAdmin，rdcConfig，level_3_name
> - 【`强制`】**禁用保留字**，如`desc、range、match、delayed`等，参考 MySQL 官方保留字
> - 【`强制`】**表必备三字段：id, gmt_create, gmt_modified**
>   - 说明：其中**id必为主键**，类型为**BIGINT UNSIGNED、单表时自增、步长为 1**。**gmt_create**, **gmt_modified**的类型均为**DATETIME类型**，前者现在时表示主动式创建，后者过去分词表示被动式更新
> - 【`推荐`】表的命名最好是遵循`业务名称_表的作用`。
>   - 正例：alipay_task 、force_project、 trade_config
> - 【`推荐`】库名与应用名称尽量一致
> - 【 参考 】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。
>   - 正例：无符号值可以避免误存负数，且扩大了表示范围

### DDL的原子化

**MySQL8新特性**

在**MySQL 8.0版本**中，InnoDB表的DDL支持事务完整性，即`DDL操作要么成功要么回滚 `。DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中

### 操作注意要求

- `表删除`操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信 息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行`备份`，这样当操作失误时可 以对数据进行恢复，以免造成无法挽回的后果。
- 同样的，在使用**ALTER TABLE**进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的`备份`，因为数据库的改变是`无法撤销`的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失



### 数据库定义

#### 创建

- 方式1：创建数据库

  ```mysql
  CREATE DATABASE 数据库名;
  ```

- 方式2：创建数据库并指定字符集

  ```mysql
  CREATE DATABASE 数据库名 CHARACTER SET 字符集;
  ```

- **方式3：判断数据库是否已经存在，不存在则创建数据库（ 推荐 ）**

  ```mysql
  CREATE DATABASE IF NOT EXISTS 数据库名;
  CREATE DATABASE IF NOT EXISTS 数据库名 CHARACTER SET 字符集;
  ```

> 注意：**DATABASE不能改名**。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。

#### 查看

- 使用/切换数据库

  ```MySQL
  USE 数据库名;
  ```

- 查看当前所有的数据库

  ```MySQL
  SHOW DATABASES; #有一个S，代表多个数据库
  ```

- 查看当前正在使用的数据库

  ```MySQL
  SELECT DATABASE(); #使用的一个 mysql 中的全局函数
  ```

- 查看指定库下所有的表

  ```MySQL
  SHOW TABLES FROM 数据库名
  ```

- 查看数据库的创建信息

  ```MySQL
  SHOW CREATE DATABASE 数据库名;
  或者：
  SHOW CREATE DATABASE 数据库名\G
  ```

> 注意：要操作表格和数据之前`必须先说明是对哪个数据库进行操作`，否则就要对所有对象加上`数据库名.`。

#### 修改

一般不会改

- 更改数据库字符集

  ```mysql
  ALTER DATABASE 数据库名 CHARACTER SET 字符集; #比如：gbk、utf8等
  ```

#### 删除

- 方式1：删除指定的数据库

  ```mysql
  DROP DATABASE 数据库名;
  ```

- **方式2：删除指定的数据库（ 推荐 ）**

  ```mysql
  DROP DATABASE IF EXISTS 数据库名;
  ```

### 数据表定义

#### 计算列

**MySQL8新特性**，这一列的数据相当于Excel中`=xxxxx`，会根据其他列动态变化

格式为：

CREATE TABLE tb(
	a INT,
	b INT,
	a INT **GENERATED ALWAYS AS** `(a + b)` **VIRTUAL**
);

##### 创建

```MySQL
CREATE TABLE tb1(
id INT,
a INT,
b INT,
c INT GENERATED ALWAYS AS (a + b) VIRTUAL
);
```

##### 插入

不添加字段c，字段c自动计算添加

```MySQL
INSERT INTO tb1(a,b) VALUES (100,200);
```

##### 更新

不修改字段c，字段c自动计算更新

```MySQL
UPDATE tb1 SET a = 500;
```

#### 创建

##### 创建全新空表

- **必须具备：**
  - CREATE TABLE权限
  - 存储空间

- **语法格式：**

```MySQL
CREATE TABLE [IF NOT EXISTS] 表名(
字段1, 数据类型 [约束条件] [默认值],
字段2, 数据类型 [约束条件] [默认值],
字段3, 数据类型 [约束条件] [默认值],
……
[表约束条件]
)[ENGINE=数据库引擎] [CHARSET=utf8mb4];

/*
必须指定：
- 表名
- 字段名，数据类型(长度)

可选指定：
- 约束条件
- 默认值
- 字段字符集
*/
```

> 加上了`IF NOT EXISTS`关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表

- **必须指定：**
  - 表名
  - 列名(或字段名)，数据类型，长度
- **可选指定：**
  - [约束条件](#约束)
  - 默认值
  - 字段字符集
- 示例：

```MySQL
CREATE TABLE dept(
-- int类型，自增
deptno INT(2) AUTO_INCREMENT,
dname VARCHAR(14) CHARACTER SET 'gbk',
loc VARCHAR(13),
-- 主键
PRIMARY KEY (deptno)
);
```

##### 基于现有表创建

- 使用**AS subquery(子查询)**选项，**将创建表和插入数据结合起来**
- 指定的列和子查询中的列要一一对应
- 通过列名和默认值定义列
- **格式**

```MySQL
CREATE TABLE 表名
	[(column, column, ...)]
AS subquery;
```

- 示例

```MySQL
#完全复制
CREATE TABLE emp1 AS SELECT * FROM employees;
#创建的emp2是空表(只复制表结构)
CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1=2;

CREATE TABLE dept80
AS
SELECT employee_id, last_name, salary*12 ANNSAL, hire_date
FROM employees
WHERE department_id = 80;
```

> **SELECT**的字段需与**FROM**的字段名相同，`如果使用别名，则新表中的字段名为别名`
> 可以理解为**查询结果表就是新表**

#### 查看

使用**DESCRIBE**或**DESC**命令，表示表结构
也可以使用**SHOW CREATE TABLE**语句查看数据表结构

> 使用**SHOW CREATE TABLE**语句不仅可以`查看表创建时的详细语句`，还可以`查看存储引擎`和`字符编码`

```mysql
DESCRIBE employees;
或
DESC employees;

mysql> desc employees;
+----------------+-------------+------+-----+---------+-------+
| Field          | Type        | Null | Key | Default | Extra |
+----------------+-------------+------+-----+---------+-------+
| employee_id    | int(6)      | NO   | PRI | 0       |       |
| first_name     | varchar(20) | YES  |     | NULL    |       |
| last_name      | varchar(25) | NO   |     | NULL    |       |
| email          | varchar(25) | NO   | UNI | NULL    |       |
| phone_number   | varchar(20) | YES  |     | NULL    |       |
| hire_date      | date        | NO   |     | NULL    |       |
| job_id         | varchar(10) | NO   | MUL | NULL    |       |
| salary         | double(8,2) | YES  |     | NULL    |       |
| commission_pct | double(2,2) | YES  |     | NULL    |       |
| manager_id     | int(6)      | YES  | MUL | NULL    |       |
| department_id  | int(4)      | YES  | MUL | NULL    |       |
+----------------+-------------+------+-----+---------+-------+
11 rows in set (0.00 sec)
```

各个字段的含义：

- **Field**：表示字段名称
- **Type**：表示字段类型
- **Null**：表示该列是否可以存储NULL值
- **Key**：表示该列是否已编制索引。`PRI`表示该列是表主键的一部分；`UNI`表示该列是UNIQUE索引的一部分；`MUL`表示在列中某个给定值允许出现多次
- **Default**：表示该列是否有默认值，如果有，那么值是多少
- **Extra**：表示可以获取的与给定列有关的附加信息，例如`AUTO_INCREMENT`等

#### 修改

**ALTER**

##### 添加字段

**ALTER**...**ADD**

- 语法格式如下：

```MySQL
ALTER TABLE 表名
ADD 字段名 字段类型 [FIRST];
# FIRST代表添加的字段放在第一位

或者

ALTER TABLE 表名
ADD 字段名 字段类型 [AFTER 字段名];
# AFTER 字段名代表添加的字段放在AFTER后字段名的后面
```

示例：

```MySQL
ALTER TABLE myemp1
ADD phone_number VARCHAR(20) FIRST;

ALTER TABLE myemp1
ADD email VARCHAR(45) AFTER emp_name;
```

##### 修改字段

**ALTER**...**MODIFY**

- 可以修改列的`数据类型`，`长度`、`默认值`、`位置`和`约束`
- 对默认值的修改`只影响今后对表的修改`
- 修改字段数据类型、长度、默认值、位置的语法格式如下：

```MySQL
ALTER TABLE 表名
MODIFY 字段名1 字段类型 [DEFAULT 默认值] [FIRST|AFTER 字段名2];
```

- 示例：

```MySQL
ALTER TABLE dept80
MODIFY salary double(9,2) default 1000;
```

##### 重命名字段

**ALTER**...**CHANGE**

- 使用**CHANGE** `old_column` `new_column` `dataType`子句重命名列。语法格式如下：

```MySQL
ALTER TABLE 表名
CHANGE 列名 新列名 新数据类型;
```

> 数据类型也可以改，内含**MODIFY**

- 示例：

```MySQL
ALTER TABLE dept80
CHANGE department_name dept_name varchar(15);
```

##### 删除字段

- 删除表中某个字段的语法格式如下：

```MySQL
ALTER TABLE 表名
DROP 字段名
```

- 示例：

```MySQL
ALTER TABLE dept80
DROP COLUMN job_id;
```

#### 重命名

- 方式一：使用**RENAME**...**TO**

```MySQL
RENAME TABLE emp
TO myemp;
```

- 方式二：使用**ALTER**...**RENAME**

```MySQL
ALTER table dept
RENAME [TO] detail_dept; -- [TO]可以省略
```

- 必须是对象的拥有者

#### 删除

**DROP**

- 在MySQL中，当一张数据表`没有与其他任何数据表形成关联关系`时，可以将当前数据表直接删除。
- 数据和结构都被删除
- 所有正在运行的相关事务被提交
- 所有相关索引被删除
- 语法格式：

```mysql
DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];
```

IF EXISTS 的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。

- 示例：

```mysql
DROP TABLE dept80;
```

- DROP TABLE 语句不能回滚

#### 清空表

- **TRUNCATE TABLE**语句：
  - 删除表中所有的数据
  - 释放表的存储空间
- 格式：

```
TRUNCATE TABLE 表名;
```

- 示例：

```MySQL
TRUNCATE TABLE detail_dept;
```

- **TRUNCATE**语句`不能回滚`，而使用**DELETE**语句删除数据，`可以回滚`

> 阿里开发规范：
>
> 【参考】**TRUNCATE TABLE**比**DELETE**速度快，且使用的系统和事务日志资源少，但**TRUNCATE**无事务且不触发**TRIGGER**，有可能造成事故，故`不建议`在开发代码中使用此语句。
>
> 说明：**TRUNCATE TABLE在功能上与不带WHERE子句的DELETE语句相同**

### <a id="约束">约束</a>(constraint)

约束是表级的强制规定。可以在**创建表**时规定约束（通过**CREATE TABLE**语句），或者在表创建之后通过**ALTER TABLE**语句规定约束

查看某个表已有的约束：

```mysql
#information_schema数据库名（系统库）
#table_constraints表名称（专门存储各个表的约束）
SELECT * FROM information_schema.table_constraints
WHERE table_name = '表名称';
```

- 根据约束数据列的限制，约束可分为：

  - **单列约束**：每个约束只约束一列
  - **多列约束**：每个约束可约束多列数据

- 根据约束的作用范围，约束可分为：

  - **列级约束**：只能作用在一个列上，跟在列的定义后面
  - **表级约束**：在表中所有字段都声明完，在所有字段的后面声明的约束。可以作用在多个列上，不与列一起，而是单独定义

  ```
                    位置           支持的约束类型             是否可以起约束名
  列级约束:       列的后面       语法都支持,但外键没有效果          不可以
  表级约束:      所有列的下面    默认和非空不支持，其他支持     可以（主键没有效果）
  ```

- 根据约束起的作用，约束可分为：

  - **NOT NULL** `非空约束`，规定某个字段不能为空
  - **UNIQUE** `唯一约束`，规定某个字段在整个表中是唯一的
  - **PRIMARY KEY** `主键`(非空且唯一)约束
  - **FOREIGN KEY** `外键`约束
  - **CHECK** `检查`约束
  - **DEFAULT** `默认值`约束

> 注意： MySQL**不支持check约束**，但可以使用check约束，而没有任何效果

#### 非空约束

**NOT NULL**：限定某个字段/某列的值不允许为空

若为空会报错，添加失败

**特点：**

- 默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型
- 非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空
- 一个表可以有很多列都分别限定了非空
- `空字符串''不等于NULL，0也不等于NULL`

##### 添加约束

- 建表时

  ```MySQL
  CREATE TABLE 表名称(
  字段名 数据类型,
  字段名 数据类型 NOT NULL,
  字段名 数据类型 NOT NULL
  );
  
  CREATE TABLE emp(
  id INT(10) NOT NULL,
  NAME VARCHAR(20) NOT NULL,
  sex CHAR NULL
  );
  ```

- 建表后

  ```mysql
  alter table 表名称 modify 字段名 数据类型 not null;
  
  ALTER TABLE emp
  MODIFY sex VARCHAR(30) NOT NULL;
  ```

  > 需要修改字段下没有null值

##### 删除约束

```mysql
#去掉not，相当于修改某个非注解字段，该字段允许为空
alter table 表名称 modify 字段名 数据类型 NULL;
或
#去掉not null，相当于修改某个非注解字段，该字段允许为空
alter table 表名称 modify 字段名 数据类型;

ALTER TABLE emp
MODIFY sex VARCHAR(30) NULL;
```

#### 唯一约束

**UNIQUE**：用来限制某个字段/某列的值不能重复，可以为null

若重复会报错，添加失败

**特点：**

- 同一个表可以有多个唯一约束
- 唯一约束可以是某`一个列`的值唯一，也可以`多个列组合`的值唯一
- **唯一性约束允许列值为空**
- 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同
- **MySQL会给唯一约束的列上默认创建一个唯一索引**

##### 添加约束

**UNIQUE和UNIQUE KEY是完全相同的。KEY可有可无，效果一样**

**UNIQUE约束可以多个字段复合使用，即UNIQUE [KEY]后`()`包裹的几个字段组合唯一**

- 建表时

  ```mysql
  # 列级约束
  create table 表名称(
      字段名 数据类型,
      字段名 数据类型 unique,
      字段名 数据类型 unique key,
      字段名 数据类型
  );
  # 表级约束
  create table 表名称(
      字段名 数据类型,
      字段名 数据类型,
      字段名 数据类型,
      [constraint 约束名(自己对约束起的名)] unique key(字段名)
  );
  
  create table student(
      sid int,
      sname varchar(20),
      tel char(11) unique,
      cardid char(18) unique key
  );
  
  CREATE TABLE USER(
      id INT NOT NULL,
      NAME VARCHAR(25),
      PASSWORD VARCHAR(16),
      -- 使用表级约束语法
      CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD)
  );
  ```

  > 表示用户名和密码组合不能重复

- 建表后

  ```mysql
  #字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的
  #方式1：
  alter table 表名称 add unique key(字段列表);
  #方式2：
  alter table 表名称 modify 字段名 字段类型 unique;
  
  ALTER TABLE USER
  ADD UNIQUE(NAME,PASSWORD);
  
  ALTER TABLE USER
  ADD CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD);
  
  ALTER TABLE USER
  MODIFY NAME VARCHAR(20) UNIQUE;
  ```

##### 删除约束

- 添加唯一性约束的列上也会自动创建唯一索引
- 删除唯一约束只能通过删除唯一索引的方式删除
- 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样
- 如果创建唯一约束时未指定名称，`如果是单列，就默认和列名相同`。`如果是组合列，那么默认和()中排在第一个的列名相同`。也可以自定义唯一性约束名

```mysql
#查看都有哪些约束
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名';

ALTER TABLE USER
DROP INDEX uk_name_pwd;
```



#### 自增约束

**AUTO_INCREMENT**：使某个字段的值自增

**特点：**

- 一个表`最多只能有一个自增长列`
- 当需要产生唯一标识符或顺序值时，可设置自增长
- 自增长列约束的列`必须是键列`（主键列，唯一键列）(否则报错)
- 自增约束的列的数据类型`必须是整数类型`
- 如果添加字段时自增列指定为`0`或`null`，会当作没有填，继续在`最大值基础上自增`；如果自增列手动指定了具体值，直接赋值为具体值
- 如果添加字段时自增列指定为`负数`，会添加成功，是负数

##### 添加约束

- 建表时

  ```mysql
  create table 表名称(
      字段名 数据类型 primary key auto_increment,
      字段名 数据类型 unique key not null,
      字段名 数据类型 unique key,
      字段名 数据类型 not null default 默认值,
  );
  create table 表名称(
      字段名 数据类型 default 默认值 ,
      字段名 数据类型 unique key auto_increment,
      字段名 数据类型 not null default 默认值,,
      primary key(字段名)
  );
  
  create table employee(
      eid int primary key auto_increment,
      ename varchar(20)
  );
  ```

- 建表后

  ```mysql
  alter table 表名称 modify 字段名 数据类型 auto_increment;
  
  alter table employee modify eid int auto_increment;
  ```

##### 删除约束

```mysql
alter table 表名称 modify 主键字段名 数据类型; #去掉auto_increment相当于删除

alter table employee modify eid int;
```

##### 自增变量的持久化

**MySQL8.0前，删除字段后 自增主键会缺失 删除字段的主键值。重启服务后自增主键重置，不再缺失。MySQL8.0后，会保存信息，重启后依然缺失**

在**MySQL 8.0**之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象`在某些情况下会导致业务主键冲突或者其他难以发现的问题`

在**MySQL 5.7**系统中，对于自增主键的分配规则，是由InnoDB数据字典 内部一个`计数器`来决定的，而该计数器只在`内存中维护`，并不会持久化到磁盘中。当`数据库重启`时，该计数器会被`初始化`。

在**MySQL 8.0**将`自增主键的计数器`持久化到`重做日志`中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。

#### 主键约束

**PRIMARY KEY**：用来唯一标识表中的一行记录。**相当于唯一约束+非空约束的组合**，主键约束列不允许重复，也不允许出现空值

一旦主键作用的字段上声明有**AUTO_INCREMENT**，则我们在添加数据时，就不要给主键对应的字段去赋值

**特点：**

- **一个表最多只能有一个主键约束**，建立主键约束可以在列级别创建，也可以在表级别上创建
- 主键约束对应着表中的一列或者多列（**复合主键**）
- 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复
- **MySQL的主键名总是PRIMARY**，就算自己命名了主键约束名也没用
- 当创建主键约束时，系统默认会在所在的`列或列组合`上建立对应的**主键索引**（能够根据主键查询的，就根据主键查询，效率更高。如果删除主键约束了，主键约束对应的索引就自动删除了
- 需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性

##### 添加约束

**PRIMARY KEY约束可以多个字段复合使用，即PRIMARY KEY后`()`包裹的几个字段组合唯一。这种情况下这些字段都不能为空且不能重复**

- 建表时

  ```mysql
  #列级模式
  create table 表名称(
      字段名 数据类型 primary key, 
      字段名 数据类型,
      字段名 数据类型
  );
  #表级模式
  create table 表名称(
      字段名 数据类型,
      字段名 数据类型,
      字段名 数据类型,
      [constraint 约束名] primary key(字段名) 
  );
  
  CREATE TABLE user1(
  id INT,
  NAME VARCHAR(15),
  PASSWORD VARCHAR(25),
  PRIMARY KEY (NAME,PASSWORD)
  );
  
  CREATE TABLE emp5(
  id INT NOT NULL AUTO_INCREMENT,
  NAME VARCHAR(20),
  pwd VARCHAR(15),
  CONSTRAINT emp5_id_pk PRIMARY KEY(id)
  );
  ```

- 建表后

  ```mysql
  #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键
  ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); 
  
  ALTER TABLE student ADD PRIMARY KEY (sid);
  LTER TABLE emp5 ADD PRIMARY KEY(NAME,pwd);
  ```

##### 删除约束

实际开发中，不会删除主键约束

```mysql
alter table 表名称 drop primary key;

ALTER TABLE student DROP PRIMARY KEY;
ALTER TABLE emp5 DROP PRIMARY KEY;
```

> 删除主键约束，不需要指定主键名，因为一个表只有一个主键，`删除主键约束后，非空还存在`

#### 外键约束

**FOREIGN KEY**：限定某个表的某个字段的引用完整性。比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分

**特点：**

1. 从表的外键列，必须`引用/参考主表的主键或唯一约束的列`，否则报错
   为什么？因为被依赖/被参考的值必须是唯一的
2. 在创建外键约束时，如果不给外键约束命名，**默认名不是列名，而是自动产生一个外键名**（例如 student_idfk_1;），也可以指定外键约束名
3. 创建(CREATE)表时就指定外键约束的话，`先创建主表，再创建从表`
4. 删表时，`先删从表`（或先删除外键约束），`再删除主表`
5. 当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据
6. 在`从表`中指定外键约束，并且`一个表可以建立多个外键约束`
7. 从表的外键列与主表被参照的列`名字可以不相同`，但是`数据类型必须一样`，`逻辑意义一致`。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can't create table'database.tablename'(errno: 150)”。 例如：都是表示部门编号，都是int类型
8. 当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是外键的约束名。（根据外键查询效率很高）
9. `删除外键约束后，必须手动删除对应的索引`

##### 主表和从表

或父表和子表

主表（父表）：被引用的表，被参考的表

从表（子表）：引用别人的表，参考别人的表

##### 约束等级

- `Cascade方式 `：在父表上update/delete记录时，同步update/delete掉子表的匹配记录
- `Set null方式` ：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null
- `No action方式` ：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作
- `Restrict方式` ：同no action， 都是立即检查外键约束
- `Set default方式` （在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置 成一个默认的值，但Innodb不能识别x

如果没有指定等级，就相当于Restrict方式。 对于外键约束，**最好是采用**:`ON UPDATE CASCADE ON DELETE RESTRICT`的方式

```mysql
create table dept(
    did int primary key, #部门编号
    dname varchar(50) #部门名称
);

create table emp(
    eid int primary key, #员工编号
    ename varchar(5), #员工姓名
    deptid int, #员工所在的部门
    foreign key (deptid) references dept(did) on update cascade on delete set null
    #把修改操作设置为级联修改等级，把删除操作设置为set null等级
);
```



##### 添加约束

**外键必须是主键或唯一约束的列**

**数据类型必须一样**

- 建表时

  ```mysql
  create table 主表名称(
      字段1 数据类型 primary key,
      字段2 数据类型
  );
  
  create table 从表名称(
      字段1 数据类型 primary key,
      字段2 数据类型,
      [CONSTRAINT <外键约束名称>] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段)
  );
  
  #(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样
  #(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样
  -- FOREIGN KEY: 在表级指定子表中的列
  -- REFERENCES: 标示在父表中的列
  
  create table dept( #主表
      did int primary key, #部门编号
      dname varchar(50) #部门名称
  );
  create table emp(#从表
      eid int primary key, #员工编号
      ename varchar(5), #员工姓名
      deptid int, #员工所在的部门
      foreign key (deptid) references dept(did) #在从表中指定外键约束
      #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号
  );
  说明：
  （1）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。
  （2）删除表时，先删除从表emp，再删除主表dept
  ```

- 建表后

  一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义。

  格式：

  ```MySQL
  ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名
  
  ALTER TABLE emp1
  ADD [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id);
  ```

##### 删除约束

```mysql
(1)第一步先查看约束名和删除外键约束
#查看某个表的约束名
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称';
ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;

(2)第二步查看索引名和删除索引。（注意，只能手动删除）
#查看某个表的索引名
SHOW INDEX FROM 表名称; 
ALTER TABLE 从表名 DROP INDEX 索引名;
```

```mysql
mysql> SELECT * FROM information_schema.table_constraints WHERE table_name = 'emp';
mysql> alter table emp drop foreign key emp_ibfk_1;
Query OK, 0 rows affected (0.02 sec)
Records: 0 Duplicates: 0 Warnings: 0

mysql> show index from emp;
mysql> alter table emp drop index deptid;
Query OK, 0 rows affected (0.01 sec)
Records: 0 Duplicates: 0 Warnings: 0
```

##### 开发场景

**问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否一定要建外键约束？**

答：不是的

**问题2：建和不建外键约束有什么区别？**

答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。

不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的 `引用完整`性 ，只能`依靠程序员的自觉`，或者是`在Java程序中进行限定`。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。

**问题3：那么建和不建外键约束和查询有没有关系？**

答：没有

> 在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会`因为外键约束的系统开销而变得非常慢`。所以， MySQL允许你不使用系统自带的外键约束，在`应用层面`完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。

**阿里开发规范**

【`强制`】**不得使用外键与级联，一切外键概念必须在应用层解决**

说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于`单机低并发 `，不适合`分布式 、 高并发集群`；级联更新是强阻塞，存在数据库`更新风暴`的风险；外键影响数据库的`插入速度`

#### 检查约束

**CHECK**：检查某个字段的值是否符号xx要求，一般指的是值的范围

**MySQL5.7**可以使用check约束，但check约束对数据验证**没有任何作用**。添加数据时，没有任何错误或警告
**MySQL 8.0**中**可以使用**check约束了

##### 添加约束

不符合则添加失败

```mysql
create table employee(
    eid int primary key,
    ename varchar(5),
    gender char check ('男' or '女')
);

CREATE TABLE temp(
id INT AUTO_INCREMENT,
NAME VARCHAR(20),
age INT CHECK(age > 20),
PRIMARY KEY(id)
);
```

#### 默认值约束

**DEFAULT**：给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值

##### 添加约束

- 建表时

  默认值约束`一般不在唯一键和主键列上加`

  ```mysql
  create table 表名称(
      字段名 数据类型 primary key,
      字段名 数据类型 unique key not null,
      字段名 数据类型 unique key,
      字段名 数据类型 not null default 默认值,
  );
  
  create table 表名称(
      字段名 数据类型 default 默认值 ,
      字段名 数据类型 not null default 默认值,
      字段名 数据类型 not null default 默认值,
      primary key(字段名),
      unique key(字段名)
  );
  
  create table employee(
  eid int primary key,
  ename varchar(20) not null,
  gender char default '男',
  tel char(11) not null default '' #默认是空字符串
  );
  ```

- 建表后

  ```mysql
  alter table 表名称 modify 字段名 数据类型 default 默认值;
  #如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了
  #同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了
  alter table 表名称 modify 字段名 数据类型 default 默认值 not null;
  
  alter table employee modify gender char default '男'; #给gender字段增加默认值约束
  alter table employee modify tel char(11) default ''; #给tel字段增加默认值约束
  ```

##### 删除约束

```mysql
alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束
alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束

#删除gender字段默认值约束，如果有非空约束，也一并删除
alter table employee modify gender char; 
#删除tel字段默认值约束，保留非空约束
alter table employee modify tel char(11) not null;
```

#### 面试

**面试1、为什么建表时，加 not null default '' 或 default 0**

不想让表中出现null值。

**面试2、为什么不想要 null 的值**

1. 不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。
2. 效率不高。影响提高索引效果。因此，我们往往在建表时`not null default ''`或 `default 0`

**面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？**

在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一 条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要 设置字段自动增加属性。

**面试4、并不是每个表都可以任意选择存储引擎？**

`外键约束(FOREIGN KEY)不能跨引擎使用`（主表从表相同）

MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的

## DCL(数据控制语言)

**Data Control Language 数据控制语言**









# Oracle





































